#+TITLE: Personal emacs config
#+STARTUP: overview

* Workarounds
** 28.0.50
#+begin_src emacs-lisp
(defun make-obsolete (obsolete-name current-name &optional when)
  "Make the byte-compiler warn that function OBSOLETE-NAME is obsolete.
OBSOLETE-NAME should be a function name or macro name (a symbol).

The warning will say that CURRENT-NAME should be used instead.
If CURRENT-NAME is a string, that is the `use instead' message
\(it should end with a period, and not start with a capital).
WHEN should be a string indicating when the function
was first made obsolete, for example a date or a release number."
  (declare (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when) "23.1"))
  (put obsolete-name 'byte-obsolete-info
       ;; The second entry used to hold the `byte-compile' handler, but
       ;; is not used any more nowadays.
       (purecopy (list current-name nil when)))
  obsolete-name)

(defmacro define-obsolete-function-alias (obsolete-name current-name
                                                        &optional when docstring)
  "Set OBSOLETE-NAME's function definition to CURRENT-NAME and mark it obsolete.

\(define-obsolete-function-alias \\='old-fun \\='new-fun \"22.1\" \"old-fun's doc.\")

is equivalent to the following two lines of code:

\(defalias \\='old-fun \\='new-fun \"old-fun's doc.\")
\(make-obsolete \\='old-fun \\='new-fun \"22.1\")

WHEN should be a string indicating when the function was first
made obsolete, for example a date or a release number.

See the docstrings of `defalias' and `make-obsolete' for more details."
  (declare (doc-string 4)
           (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when &optional docstring) "23.1"))
  `(progn
     (defalias ,obsolete-name ,current-name ,docstring)
     (make-obsolete ,obsolete-name ,current-name ,when)))

(defun make-obsolete-variable (obsolete-name current-name &optional when access-type)
  "Make the byte-compiler warn that OBSOLETE-NAME is obsolete.
The warning will say that CURRENT-NAME should be used instead.
If CURRENT-NAME is a string, that is the `use instead' message.
WHEN should be a string indicating when the variable
was first made obsolete, for example a date or a release number.
ACCESS-TYPE if non-nil should specify the kind of access that will trigger
  obsolescence warnings; it can be either `get' or `set'."
  (declare (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when &optional access-type) "23.1"))
  (put obsolete-name 'byte-obsolete-variable
       (purecopy (list current-name access-type when)))
  obsolete-name)

(defmacro define-obsolete-variable-alias (obsolete-name current-name
						        &optional when docstring)
  "Make OBSOLETE-NAME a variable alias for CURRENT-NAME and mark it obsolete.
This uses `defvaralias' and `make-obsolete-variable' (which see).
See the Info node `(elisp)Variable Aliases' for more details.

If CURRENT-NAME is a defcustom or a defvar (more generally, any variable
where OBSOLETE-NAME may be set, e.g. in an init file, before the
alias is defined), then the define-obsolete-variable-alias
statement should be evaluated before the defcustom, if user
customizations are to be respected.  The simplest way to achieve
this is to place the alias statement before the defcustom (this
is not necessary for aliases that are autoloaded, or in files
dumped with Emacs).  This is so that any user customizations are
applied before the defcustom tries to initialize the
variable (this is due to the way `defvaralias' works).

WHEN should be a string indicating when the variable was first
made obsolete, for example a date or a release number.

For the benefit of Customize, if OBSOLETE-NAME has
any of the following properties, they are copied to
CURRENT-NAME, if it does not already have them:
`saved-value', `saved-variable-comment'."
  (declare (doc-string 4)
           (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when &optional docstring) "23.1"))
  `(progn
     (defvaralias ,obsolete-name ,current-name ,docstring)
     ;; See Bug#4706.
     (dolist (prop '(saved-value saved-variable-comment))
       (and (get ,obsolete-name prop)
            (null (get ,current-name prop))
            (put ,current-name prop (get ,obsolete-name prop))))
     (make-obsolete-variable ,obsolete-name ,current-name ,when)))
#+end_src

* Setup
** Doom setup
#+INCLUDE: "./personal.el" src emacs-lisp

#+BEGIN_SRC emacs-lisp

;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
(setq doom-font (font-spec :family "Jetbrains Mono" :size 14))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-one)

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c g k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c g d') to jump to their definition and see how
;; they are implemented.

#+END_SRC
** Clear authinfo cache
Somewhere this is filled with trash. Clear it
#+BEGIN_SRC emacs-lisp
(after! auth-source (auth-source-forget-all-cached) )
#+END_SRC
** Mac fixes
*** Fix mac modifiers
#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta nil)
(setq mac-command-key-is-meta t)
(setq mac-command-modifier 'meta)
(setq mac-option-modifier nil)
#+END_SRC
*** Fix frame size
To make sure frame has correct size on yabai
#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC
** COMMENT EXWM
*** Functions
**** Utilities
Rename buffer to EXWM window name
#+begin_src emacs-lisp
(defun my/exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))
#+end_src
Helper function to start background apps
#+begin_src emacs-lisp
(defun my/run-in-background (command)
  (let ((command-parts (split-string command "[ ]+")))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))
#+end_src

Extra config after exwm is initialized
#+begin_src emacs-lisp
(defun my/exwm-init-hook ()
  (exwm-workspace-switch-create 1)

  (setq display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)

  (my/run-in-background "~/.config/polybar/launch_polybar.sh")
  (my/run-in-background "dunst")
  (my/run-in-background "nm-applet")
  (my/run-in-background "pasystray")
  (my/run-in-background "blueman-applet")
  )
#+end_src
**** Insert/normal state
#+begin_src emacs-lisp
(defun my/exwm-enter-insert-state ()
  "Simulate insert state by using line mode without passthrough"
  (interactive)
  (setq exwm-input-line-mode-passthrough nil)
  (exwm-input-grab-keyboard)
  (evil-insert-state))
#+end_src

#+begin_src emacs-lisp
(defun my/exwm-enter-normal-state ()
  "Simulate normal state by using line mode with passthrough, i.e. forward all commands to emacs"
  (interactive)
  (setq exwm-input-line-mode-passthrough t)
  (call-interactively 'exwm-input-grab-keyboard)
  (evil-normal-state))
#+end_src

#+begin_src emacs-lisp
(defun my/exwm-escape ()
  "Switch to normal state, and cancel possible fullscreen layout.  Also close minibuffer."
  (interactive)
  (my/exwm-enter-normal-state)
  (exwm-layout-unset-fullscreen)
  (when (active-minibuffer-window)
    (minibuffer-keyboard-quit)))
#+end_src

#+begin_src emacs-lisp
(defun my/exwm-enter-char-mode ()
  "Enter EXWM char mode."
  (interactive)
  (when exwm--id
    (my/exwm-enter-insert-state)
    (call-interactively 'exwm-input-release-keyboard)))
#+end_src
*** Keybindings
**** Global keys
#+begin_src emacs-lisp
(defun my/exwm-set-global-keys ()
  (setq exwm-input-global-keys
        `(
          ;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
          ([?\s-r] . exwm-reset)
          ([?\C-q] . my/exwm-escape)
          ([?\s-c] . my/exwm-enter-char-mode)

          ;; Move between windows
          ([s-left] . windmove-left)
          ([s-right] . windmove-right)
          ([s-up] . windmove-up)
          ([s-down] . windmove-down)
          ([?\s- ] . counsel-linux-app)

          ;; Launch applications via shell command
          ([?\s-&] . (lambda (command)
                       (interactive (list (read-shell-command "$ ")))
                       (start-process-shell-command command nil command)))

          ;; Switch workspace
          ([?\s-w] . exwm-workspace-switch)

          ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))))
  
  (evil-define-key 'normal exwm-mode-map (kbd "i") 'my/exwm-enter-insert-state)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-1>" ) 'my/exwm-enter-insert-state)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-2>" ) 'my/exwm-enter-insert-state)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-3>" ) 'my/exwm-enter-insert-state)
  )
#+end_src
**** Window management
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("e" . "EXWM")
       :desc "Reset" "r" #'exwm-reset
       :desc "Floating hide" "h" #'exwm-floating-hide
       :desc "Switch workspace" "w" #'exwm-workspace-switch
       :desc "Add workspace" "a" #'exwm-workspace-add
       :desc "Delete workspace" "d" #'exwm-workspace-delete
       :desc "Move workspace" "m" #'exwm-workspace-move
       :desc "Swap workspace" "s" #'exwm-workspace-swap
       :desc "Detatch minibuffer" "Md" #'exwm-workspace-detach-minibuffer
       :desc "Attach minibuffer" "Ma" #'exwm-workspace-attach-minibuffer

       ))
;; (map! :leader
;;       (:prefix ("e"  "EXWM")
;;        :desc "r" #'exwm-reset
;;        ;; :desc "h" #'exwm-floating-hide
;;        ;; :desc "w" #'exwm-workspace-switch
;;        ;; :desc "a" #'exwm-workspace-add
;;        ;; :desc "d" #'exwm-workspace-delete
;;        ;; :desc "m" #'exwm-workspace-move
;;        ;; :desc "s" #'exwm-workspace-swap
;;        ;; :desc "Md" #'exwm-workspace-detach-minibuffer
;;        ;; :desc "Ma" #'exwm-workspace-attach-minibuffer
;;        ) )
#+end_src
*** Initialize
#+begin_src emacs-lisp
(set-popup-rule! "^\\*EXWM" :ignore t)

(use-package! exwm
  :custom
  (exwm-workspace-number 3)
  (exwm-workspace-show-all-buffers t)

  :config
  (require 'exwm-randr)

  (setq exwm-randr-workspace-output-plist '(1 "DP-2" 2 "DP-4"))
  (add-hook 'exwm-randr-screen-change-hook
            (lambda ()
              (start-process-shell-command
               "xrandr" nil "xrandr --output DP-2 --auto --left-of DP-4 --primary")))

  (exwm-randr-enable)

  ;; (require 'exwm-systemtray)
  ;; (exwm-systemtray-enable)
  (add-hook 'exwm-update-class-hook #'my/exwm-update-class)
  (add-hook 'exwm-init-hook #'my/exwm-init-hook)
  (add-hook 'exwm-manage-finish-hook #'my/exwm-enter-insert-state)
  (my/exwm-set-global-keys)

  )
#+end_src
*** Desktop environment
Handle media keys and such
#+begin_src emacs-lisp
(use-package! desktop-environment
  :after exwm
  :config (desktop-environment-mode))
#+end_src
* Keybindings
* Plugin configuration
** mmm-mode
#+BEGIN_SRC emacs-lisp
(use-package! mmm-mode)
#+END_SRC
** Org mode
*** Setup
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org/")

#+end_src
*** org-roam
**** File locations
Org roam will track all org files
#+begin_src emacs-lisp
(setq org-roam-directory  org-directory)
#+end_src
but only capture to the roam directory to not create a mess with normal org files
#+begin_src emacs-lisp
(setq org-roam-capture-templates
      '(("d" "default" plain #'org-roam-capture--get-point "%?" :file-name "roam/%<%Y%m%d%H%M%S>-${slug}" :head "#+title: ${title}\n" :unnarrowed t)))
#+end_src
**** Setup
#+begin_src emacs-lisp
(setq org-roam-graph-viewer nil)
#+end_src
**** Dailies
Daily notes goes to ~org/daily~
#+begin_src emacs-lisp
(setq org-roam-dailies-directory "daily/")
#+end_src
Set up two contexts. One for random notes and another for storing link to capture location
#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")
        ("c" "With context" entry
         #'org-roam-capture--get-point
         "* %?\n%a"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")))
#+end_src
Probably a temporary fix to make SPC-n-r consistent with SPC-m-m bindings
#+begin_src emacs-lisp
(map! :leader
      (:prefix "n"
       (:prefix "r"
        (:prefix "d"
         :desc "Capture daily" "n" #'org-roam-dailies-capture-today))))
#+end_src
**** Fix agenda category
#+begin_src emacs-lisp
(setq org-agenda-prefix-format
      '((agenda . " %i %-12:(+org-entry-category)%?-12t% s")
        (todo . " %i %-12:(+org-entry-category)")
        (tags . " %i %-12:(+org-entry-category)")
        (search . " %i %-12:(+org-entry-category)")))

(defun +org-entry-category ()
  "Get category of item at point.

Supports `org-roam' filenames by chopping prefix cookie."
  (+string-chop-prefix-regexp
   "^[0-9]+\\-"
   (or (org-entry-get nil "CATEGORY")
       "")))

;; requires s.el
(defun +string-chop-prefix-regexp (prefix s)
  "Remove PREFIX regexp if it is at the start of S."
  (s-chop-prefix (car (s-match prefix s)) s))
#+end_src
*** Looks
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " â–¼")
#+END_SRC
*** org-agenda
**** Popup
Agenda window shoult show in a popup window
#+BEGIN_SRC emacs-lisp
(after! org-agenda
  (set-popup-rule! "^\\*Org Agenda\\*"
    :side 'right
    :size 120
    :modeline t)
  )
#+END_SRC
**** Agenda files
Recursively find files in ~org-directory~
#+BEGIN_SRC emacs-lisp
(defun refresh-org-agenda-files ()
  (setq org-agenda-files
        (append
         (directory-files-recursively org-directory "\.org$")
         ;; (if (boundp 'org-jira-working-dir)
         ;;     (directory-files-recursively org-jira-working-dir "\.org$")
         ;;   '())
         )))

(defun refresh-org-agenda-advice (orig-fun &rest args)
  (message "Refresh org-agenda files")
  (refresh-org-agenda-files)
  (apply orig-fun args))

(after! org-agenda
  (advice-add  'org-agenda-redo :around #'refresh-org-agenda-advice)
  (refresh-org-agenda-files))

#+END_SRC
**** org-super-agenda
#+BEGIN_SRC emacs-lisp
(use-package! org-super-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-header-map (make-sparse-keymap)
        org-agenda-start-with-log-mode t))
(custom-set-faces
 '(org-super-agenda-header ((t (:inherit org-agenda-structure :foreground  "#a9a1e1")))))
#+END_SRC
***** Define the groups
****** Workday
The workday page will show
- Jira issues I am currently working on
- Tasks scheduled for today
- Other work tasks
- A timeline of all meetings scheduled today
  #+BEGIN_SRC emacs-lisp
(defun my/create-agenda-workday ()
  '("w" "Workday"
    ((alltodo "" ((org-agenda-span 'day)
                  (org-super-agenda-groups
                   '(
                     (:name "JIRA-issues"
                      :file-path "/org-jira/")
                     (:name "Today"
                      :and (:not (:category "private")
                            :scheduled today)
                      :and (:not (:category "private")
                            :scheduled past)
                      )
                     (:name "Unscheduled"
                      :category "work")
                     (:discard (:anything t))

                     ))))
     (agenda "" ((org-agenda-span 'day)
                 (org-agenda-start-day nil)
                 (org-agenda-overriding-header "")
                 (org-agenda-time-grid '((daily today require-timed)
                                         (800 1000 1200 1400 1600 1800 2000)
                                         "......" "----------------"))
                 (org-agenda-skip-scheduled-if-done t)
                 (org-agenda-skip-deadline-if-done t)
                 (org-agenda-include-deadlines t)
                 (org-agenda-include-diary t)
                 (org-agenda-block-separator nil)
                 (org-agenda-compact-blocks t)
                 (org-agenda-start-with-log-mode nil)
                 (org-agenda-show-log nil)
                 (org-super-agenda-groups
                  '((:name "Today's meetings"
                     :time-grid t
                     :and (:date today
                           :not (:tag "my-issues")
                           )
                     ;; :scheduled today
                     )
                    (:discard (:anything t))))))))
  )
  #+END_SRC
****** Worklog
Show a timeline of the work I clocked and meetings attended for a given day
#+BEGIN_SRC emacs-lisp
(defun my/create-agenda-worklog ()
  '("l" "Logged work"
    ((agenda ""
             ((org-agenda-span 'day)
              (org-agenda-start-day "-1d")
              (org-agenda-time-grid '((daily require-timed)
                                      (800 1000 1200 1400 1600 1800 2000)
                                      "......" "----------------"))
              (org-super-agenda-groups
               '((:name "What I did"
                  :time-grid t)
                 (:discard (:anything t)))
               ))))))
#+END_SRC

***** And register them
  #+BEGIN_SRC emacs-lisp
  (after! org-super-agenda
    (setq org-agenda-custom-commands
          (list (my/create-agenda-workday)
                (my/create-agenda-worklog))))
  #+END_SRC
*** org-capture
Copied from doom org-capture autoload. Should figure out a better way to do this
#+BEGIN_SRC emacs-lisp
(after! org-capture
  (defun +org--capture-ensure-heading (headings &optional initial-level)
    (if (not headings)
        (widen)
      (let ((initial-level (or initial-level 1)))
        (if (and (re-search-forward (format org-complex-heading-regexp-format
                                            (regexp-quote (car headings)))
                                    nil t)
                 (= (org-current-level) initial-level))
            (progn
              (beginning-of-line)
              (org-narrow-to-subtree))
          (goto-char (point-max))
          (unless (and (bolp) (eolp)) (insert "\n"))
          (insert (make-string initial-level ?*)
                  " " (car headings) "\n")
          (beginning-of-line 0))
        (+org--capture-ensure-heading (cdr headings) (1+ initial-level)))))

  (defun +org--capture-central-file (file project)
    (let ((file (expand-file-name file org-directory)))
      (set-buffer (org-capture-target-buffer file))
      (org-capture-put-target-region-and-position)
      (widen)
      (goto-char (point-min))
      ;; Find or create the project headling
      (+org--capture-ensure-heading
       (append (org-capture-get :parents)
               (list project (org-capture-get :heading))))))
  )
#+END_SRC

**** Templates
***** Template strings
#+BEGIN_SRC emacs-lisp
(defvar my/org-template-todo-string "** TODO %?\n%i\n%a")
(defvar my/org-template-note-string "* %U %?\n %i\n %a")
#+END_SRC

***** Centralized projects
Project entries should go in projects.org file under ~projectile-project-name~ headline
#+BEGIN_SRC emacs-lisp
(defun +org-capture-central-project-file ()
  "File for project notes and tasks"
  (+org--capture-central-file "projects.org" (projectile-project-name)))
#+END_SRC
****** todo
Todos goes under ~Tasks~
#+BEGIN_SRC emacs-lisp
(defun my/org-template-project-todo ()
  '("Projects"
    entry (function +org-capture-central-project-file)
    "** TODO %?\n%i\n%a"
    :heading "Tasks" :prepend nil))
#+END_SRC
****** note
~ Notes goes under ~notes~
#+BEGIN_SRC emacs-lisp
(defun my/org-template-project-note ()
  '("Project notes"
    entry (function +org-capture-central-project-file)
    "* %U %?\n %i\n %a"
    :heading "Notes" :prepend t)
  )
#+END_SRC
***** Personal
#+BEGIN_SRC emacs-lisp
(defun +org-capture-personal-inbox ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "private.org" "Inbox"))
#+END_SRC
****** todo
#+BEGIN_SRC emacs-lisp
(defun my/org-template-personal-todo ()
      `("Personal todo"
        entry (function +org-capture-personal-inbox)
        ;; entry (function (+org--capture-central-file "private.org" "Inbox"))
        "** TODO %?\n%i"
        :heading "Tasks" :prepend nil))
#+END_SRC
****** note
#+BEGIN_SRC emacs-lisp
(defun my/org-template-personal-note ()
      `("Personal notes"
        entry (function +org-capture-personal-inbox)
        "* %U %?\n %i"
        :heading "Notes" :prepend t)
      )
#+END_SRC
***** Work
#+BEGIN_SRC emacs-lisp
(defun +org-capture-work-inbox ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "work.org" "Inbox"))
#+END_SRC
****** todo
#+BEGIN_SRC emacs-lisp
(defun my/org-template-work-todo ()
      `("Work todo"
        entry (function +org-capture-work-inbox)
        "** TODO %?\n%i"
        :heading "Tasks" :prepend nil))
#+END_SRC
****** note
#+BEGIN_SRC emacs-lisp
(defun my/org-template-work-note ()
      `("Work notes"
        entry (function +org-capture-work-inbox)
        "* %U %?\n %i"
        :heading "Tasks" :prepend t)
      )
#+END_SRC
***** Annoyance
Capture annoyances for retro
#+BEGIN_SRC emacs-lisp
(defun +org-capture-work-annoyances ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "work.org" "Retro"))
(defun my/org-template-work-annoyance ()
  `("Annoyances"
    entry (function +org-capture-work-annoyances)
    "* %U %?\n %i"
    :heading ,(format-time-string "Week: %V"))
  )
#+END_SRC
***** Update list
#+BEGIN_SRC emacs-lisp
(after! org-capture
  (setq org-capture-templates
        `(
          ("t" . ,(my/org-template-personal-todo))
          ("n" . ,(my/org-template-personal-note))

          ("p" "Project")
          ("pt" . ,(my/org-template-project-todo))
          ("pn" . ,(my/org-template-project-note))

          ("w" "Work")
          ("wt" . ,(my/org-template-work-todo))
          ("wn" . ,(my/org-template-work-note))
          ("wa" . ,(my/org-template-work-annoyance))
          )))
#+END_SRC
*** org-depend
#+BEGIN_SRC emacs-lisp
(after! org
  (require 'org-depend))
#+END_SRC
*** org-jira
#+BEGIN_SRC emacs-lisp
(use-package! org-jira
  :commands (org-jira-mode org-jira-get-issues org-jira-update-worklogs-from-org-clocks)
  :init
  (require 'cl)

  (setq org-jira-working-dir "~/Dropbox/org/org-jira"
        org-jira-use-status-as-todo nil
        org-jira-done-states '("Done" "Prod" "PROD" "Closed" "Resolved")
        org-jira-jira-status-to-org-keyword-alist
        '(("In Progress" . "STRT")
          ("DEV" . "DONE")
          ("Demo" . "DONE")
          ("Pull request" . "HOLD")
          ("Prod" . "DONE")))
  (make-directory org-jira-working-dir 'parents)
  )
#+END_SRC
*** ical2org
#+BEGIN_SRC emacs-lisp
(use-package! ical2org)
#+END_SRC
*** org tanglesync
#+BEGIN_SRC emacs-lisp
(use-package! org-tanglesync
  :hook ((org-mode . org-tanglesync-mode)
         ;; enable watch-mode globally:
         ((prog-mode text-mode) . org-tanglesync-watch-mode))
  :init
  (setq org-tanglesync-watch-files '("~/code/technipfmc/access-management/pentest/usermutation.org")
        org-tanglesync-watch-mode 1)

  :bind
  (( "C-c M-i" . org-tanglesync-process-buffer-interactive)
   ( "C-c M-a" . org-tanglesync-process-buffer-automatic)))
#+END_SRC
*** Visual fill column
#+BEGIN_SRC emacs-lisp
(defun efs/org-mode-visual-fill ()
  (setq visual-fill-column-width 130)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . efs/org-mode-visual-fill))
#+END_SRC
*** Custom configuration
**** jira/pomodoro
Insert the task id from last started pomodoro
#+begin_src emacs-lisp
(when (featurep! :lang org +pomodoro)
  (defun my/get-task-id ()
    (save-window-excursion
      (org-clock-goto)
      (cdr (assoc "ID" (org-entry-properties)))))

  (defun my/insert-task-id ()
    (interactive)
    (let ((id (my/get-task-id)))
      (if id (progn
               (evil-append 1)
               (insert id)
               (evil-normal-state)))))

  (map! :leader
        (:prefix "i"
         :desc "Task ID" "t" #'my/insert-task-id
         ))
  )
#+end_src
**** Import files
Copy the file into dropbox and insert a link to it
#+begin_src emacs-lisp
(setq my/org-file-import-dir "~/Dropbox/org/filer")

(defun my/import-file ()
  "Select a file into 'my/org-file-import-dir'"
  (interactive)
  (let* ((imported-file-link nil))
    (save-window-excursion
      (counsel-find-file "~/")
      (let* ((old-file-name (file-name-nondirectory (buffer-file-name)))
             (new-dirname (format "%s/%s/%s"
                                  my/org-file-import-dir
                                  (format-time-string "%Y" (current-time))
                                  (format-time-string "%m" (current-time))
                                  ))
             (new-file-path (format "%s/%s-%s" new-dirname
                                    (format-time-string "%Y%m%d%H%M%S" (current-time))
                                    old-file-name)))
        (message "%s -> %s" old-file-name new-file-path)
        (make-directory new-dirname 'parents)
        (copy-file (buffer-file-name) new-file-path)
        (setq imported-file (format "[[%s][%s]]" new-file-path old-file-name))
        ))
    (insert imported-file))
  )
#+end_src

**** Open notes in workspace
Set ~org-roam-find-file~ as default note finding binding. It will not include non-org files.
#+begin_src emacs-lisp
(global-set-key [remap +default/find-in-notes] #'org-roam-find-file)
#+end_src

Make sure notes are opened in ~Notes~ workspace
#+begin_src emacs-lisp
(defun my/switch-to-notes-workspace ()
  "Open notes workspace. If it doesn't exist, open roam index."
  (let ((exists (+workspace-exists-p "Notes")))
    (+workspace-switch "Notes" t)
    (when (not exists)
      (org-roam-jump-to-index))
    (+workspace/display)))

(advice-add 'org-roam-find-file :before #'my/switch-to-notes-workspace)
(advice-add '+default/org-notes-search :before #'my/switch-to-notes-workspace)
(advice-add 'org-agenda-switch-to :before #'my/switch-to-notes-workspace)
#+end_src
** Calendar
Monday is first day of the week
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
(map! (:leader
       :prefix-map ("o" . "open")
       :desc "calendar" "c" #'=calendar))
#+END_SRC
** Ivy
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion ivy)
  (setq ivy-use-selectable-prompt t)
  )
#+END_SRC
** Tree sitter
#+BEGIN_SRC emacs-lisp
(use-package! tree-sitter
  :defer t
  :config
  (require 'tree-sitter-langs))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(setq projectile-project-search-path '("~/code" "~/code/work")
      projectile-switch-project-action 'projectile-vterm)
#+END_SRC
** Lastpass
#+BEGIN_SRC emacs-lisp
(use-package! lastpass
  :custom
  (lastpass-user user-mail-address)
  (lastpass-trust-login t)
  :config
  (lastpass-auth-source-enable)
)
#+END_SRC
** Webkit
#+begin_src emacs-lisp
(use-package! webkit)
#+end_src
** Terminal
*** vterm
#+begin_src emacs-lisp
(when (featurep! :term vterm)
  (setq vterm-buffer-name-string "vterm: %s"))
#+end_src
** LSP
#+begin_src emacs-lisp
(setq lsp-file-watch-threshold 10000)
#+end_src
* Languages
** Web
*** nvm
#+begin_src emacs-lisp
(use-package! nvm
  :config
  (nvm-use "14"))
#+end_src
*** typescript
#+BEGIN_SRC emacs-lisp
(setq-hook! 'typescript-mode-hook +format-with-lsp nil)
(setq-hook! 'typescript-tsx-mode-hook +format-with-lsp nil)
(add-hook 'typescript-mode-hook #'tree-sitter-hl-mode)
(add-hook 'typescript-tsx-mode-hook #'tree-sitter-hl-mode)
(after! typescript
  (setq typescript-indent-level 2
        lsp-clients-typescript-log-verbosity "debug"
        lsp-clients-typescript-plugins
        (vector
         (list :name "@vsintellicode/typescript-intellicode-plugin"
               :location "~/.vscode/extensions/visualstudioexptteam.vscodeintellicode-1.2.10/")))
  (when (not (assoc 'typescript-tsx-mode tree-sitter-major-mode-language-alist))
    (add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx)))

  )
#+END_SRC
** GraphQL
Set up graphql with lsp
#+BEGIN_SRC emacs-lisp
(use-package! graphql-mode
  :hook
  (graphql-mode . lsp!)
  :config
  (after! lsp-mode

    (defcustom lsp-vscode-graphql-debug nil "Enable debug logs" :type
      '(repeat boolean))
    (defcustom lsp-vscode-graphql-trace-server "off" "Enable tracing for language server" :type
      '(repeat string))
    (defcustom lsp-vscode-graphql-show-exec-codelens t "Show codelens to execute operations inline" :type 'boolean)
    (defcustom lsp-vscode-graphql-use-schema-file-definitions nil "Use local SDL/IDL files for definition lookups. Default is to use generated_schema.graphql from GraphQL Config settings for definitions" :type 'boolean)
    (defcustom lsp-graphql-config-load-root-dir nil "Base dir for graphql config loadConfig()" :type
      '(repeat string))
    (defcustom lsp-graphql-config-load-file-path nil "filePath for graphql config loadConfig()" :type
      '(repeat string))
    (defcustom lsp-graphql-config-load-legacy nil "legacy mode for graphql config v2 config" :type 'boolean)
    (defcustom lsp-graphql-config-load-config-name nil "optional <configName>.config.js instead of default `graphql`" :type
      '(repeat string))
    (defcustom lsp-graphql-config-dot-env-path nil "optional .env load path, if not the default" :type
      '(repeat string))
    (lsp-register-custom-settings
     '(("graphql-config.dotEnvPath" lsp-graphql-config-dot-env-path)
       ("graphql-config.load.configName" lsp-graphql-config-load-config-name)
       ("graphql-config.load.legacy" lsp-graphql-config-load-legacy t)
       ("graphql-config.load.filePath" lsp-graphql-config-load-file-path)
       ("graphql-config.load.rootDir" lsp-graphql-config-load-root-dir)
       ("vscode-graphql.useSchemaFileDefinitions" lsp-vscode-graphql-use-schema-file-definitions t)
       ("vscode-graphql.showExecCodelens" lsp-vscode-graphql-show-exec-codelens t)
       ("vscode-graphql.trace.server" lsp-vscode-graphql-trace-server)
       ("vscode-graphql.debug" lsp-vscode-graphql-debug)))
    (lsp-register-client
     (make-lsp-client :new-connection
                      (lsp-tcp-connection (lambda (port) `("graphql-lsp" "server" "-m" "socket" "-p" ,(number-to-string port))))
                      :major-modes '(graphql-mode)
                      :initialization-options (lambda () `())
                      :server-id 'graphql))
    (add-to-list 'lsp-language-id-configuration '(graphql-mode . "graphql"))
    (lsp-enable-which-key-integration 'graphql-mode)
    )
  )
#+END_SRC
Set up from org mode as well
#+BEGIN_SRC emacs-lisp
(use-package! ob-graphql)
#+END_SRC
*** Syntax highlight in js/jsx/ts/tsx
#+BEGIN_SRC emacs-lisp
(after! (:and graphql-mode mmm-mode typescript-mode)
  (mmm-add-classes
   '((ts-graphql
      :submode graphql-mode
      :face mmm-declaration-submode-face
      :front "[^a-zA-Z]gql`" ;; regex to find the opening tag
      :back "`"))) ;; regex to find the closing tag
  (mmm-add-mode-ext-class 'typescript-mode nil 'ts-graphql)
  (setq mmm-global-mode 'maybe)
  (setq mmm-submode-decoration-level 0)
  )
#+END_SRC
** Rescript (ReasonML)
#+BEGIN_SRC emacs-lisp
(use-package! reason-mode
  :mode ("\\.re?s\\'" . reason-mode)
  :config
  (after! lsp-mode
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "/usr/bin/reason-language-server")
                      :major-modes '(reason-mode)
                      :notification-handlers (ht ("client/registerCapability" 'ignore))
                      :priority 1
                      :server-id 'reason-ls)))

  (add-hook 'reason-mode-local-vars-hook #'lsp!)
  )
#+END_SRC
* Fun
** Speed types
#+BEGIN_SRC
(use-package! speed-type)
#+END_SRC

