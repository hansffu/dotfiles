#+TITLE: Personal emacs config
#+STARTUP: overview

* Workarounds
* Setup
** init.el
:HELPTEXT:
This file controls what Doom modules are enabled and what order they load in.
Remember to run 'doom sync' after modifying it!

NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
     documentation. There you'll find information about all of Doom's modules
     and what flags they support.

NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
     'C-c g k' for non-vim users) to view its documentation. This works on
     flags as well (those symbols that start with a plus).

     Alternatively, press 'gd' (or 'C-c g d') on a module to browse its
     directory (for easy access to its source code).
:END:
#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

(doom! :input
       ;;chinese
       ;;japanese

       :completion
       (company
        +childframe)           ; the ultimate code completion backend
       ;; helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       ;;(vertico +icons)
        (ivy +icons
             ;; +childframe
             ;; +fuzzy
             +prescient)
                                        ; a search engine for love and life

       :ui
       ;;deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       doom-quit         ; DOOM quit-message prompts when you quit Emacs
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       hydra
       ;;indent-guides     ; highlighted indent columns
       modeline          ; snazzy, Atom-inspired modeline, plus API
       nav-flash         ; blink the current line after jumping
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup            ; tame sudden yet inevitable temporary windows
        +all             ; catch all popups that start with an asterix
        +defaults)       ; default popup rules
       ligatures       ; replace bits of code with pretty symbols
       ;; tabs              ; an tab bar for Emacs
       (treemacs +lsp)          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       window-select     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       format  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       lispy             ; vim for lisp, for people who don't like vim
       multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;; parinfer          ; turn lisp into python, sort of
       rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       ;;word-wrap         ; soft wrapping with language-aware indent

       :emacs
       (dired +icons)             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       (ibuffer +icons)           ; interactive buffer management
       vc                ; version-control and Emacs, sitting in a tree
       (undo +tree)

       :term
       eshell            ; a consistent, cross-platform shell (WIP)
       ;;shell             ; a terminal REPL for Emacs
       ;;term              ; terminals in Emacs
       vterm             ; another terminals in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       (spell +flyspell +aspell)             ; tasing you for misspelling mispelling
       ;;grammar           ; tasing grammar mistake every you make

       :tools
       ;;ansible
       (debugger +lsp)          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       (docker +lsp)
       ;;editorconfig      ; let someone else argue about tabs vs spaces
       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       (lookup           ; helps you navigate your code and documentation
        +docsets)        ; ...or in Dash docsets locally
       (lsp +peek)
       ;;macos             ; MacOS-specific commands
       (magit +forge)             ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       rgb               ; creating color strings
       (terraform +lsp)         ; infrastructure as code
       ;;tmux              ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp
       taskrunner

       :lang
       ;;agda              ; types of types of types of types...
       ;;assembly          ; assembly for fun or debugging
       (beancount +lsp)
       ;;cc                ; C/C++/Obj-C madness
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;elixir            ; erlang done right
       elm               ; care for a cup of TEA?
       emacs-lisp        ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp           ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;go                ; the hipster dialect
       graql
       (haskell +dante)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ;
       (java +lsp) ; the poster child for carpal tunnel syndrome
       (javascript +lsp)        ; all(hope(abandon(ye(who(enter(here))))))
       (json +lsp)
       ;;julia             ; a better, faster MATLAB
       (kotlin +lsp)            ; a better, slicker Java(Script)
       ;;latex             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ;; ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org              ; organize your plain life in plain text
        +dragndrop       ; drag & drop files/images into org buffers
        +pretty
        +roam
        ;;+hugo            ; use Emacs for hugo blogging
        ;;+jupyter        ; ipython/jupyter support for babel
        ;; +pandoc          ; export-with-pandoc support
        +pomodoro        ; be fruitful with the tomato technique
        +present)        ; using org-mode for presentations
       ;;perl              ; write code no one else can comprehend
       ;;php               ; perl's insecure younger brother
       plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       (python +lsp)            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;ruby              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       sh                ; she sells {ba,z,fi}sh shells on the C xor
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       web               ; the tubes
       yaml

       :email
       (mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       calendar
       ;;irc               ; how neckbeards socialize
       (rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought
       slack
       spotify
       ;; eaf
       everywhere

       :config
       literate
       (default +bindings +smartparens))
#+end_src
** packages.el
Temporarily tangle this file here until I move them to a more logical spot
:HELPTEXT:
To install a package with Doom you must declare them here, run 'doom sync' on
the command line, then restart Emacs for the changes to take effect.
Alternatively, use M-x doom/reload.

WARNING: Disabling core packages listed in ~/.emacs.d/core/packages.el may
have nasty side-effects and is not recommended.


All of Doom's packages are pinned to a specific commit, and updated from
release to release. To un-pin all packages and live on the edge, do:
                                     ;(unpin! t)

...but to unpin a single package:
                                     ;(unpin! pinned-package)
Use it to unpin multiple packages
                                     ;(unpin! pinned-package another-pinned-package)


To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
                                     ;(package! some-package)

To install a package directly from a particular repo, you'll need to specify
a `:recipe'. You'll find documentation on what `:recipe' accepts here:
https://github.com/raxod502/straight.el#the-recipe-format
                                     ;(package! another-package
                                     ;  :recipe (:host github :repo "username/repo"))

If the package you are trying to install does not contain a PACKAGENAME.el
file, or is located in a subdirectory of the repo, you'll need to specify
`:files' in the `:recipe':
                                     ;(package! this-package
                                     ;  :recipe (:host github :repo "username/repo"
                                     ;           :files ("some-file.el" "src/lisp/*.el")))

If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the `:disable' property:
                                     ;(package! builtin-package :disable t)

You can override the recipe of a built in package without having to specify
all the properties for `:recipe'. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
                                     ;(package! builtin-package :recipe (:nonrecursive t))
                                     ;(package! builtin-package-2 :recipe (:repo "myfork/package"))

Specify a `:branch' to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't 'master' (which
our package manager can't deal with; see raxod502/straight.el#279)
                                        ;(package! builtin-package :recipe (:branch "develop"))
:END:
#+begin_src emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+end_src
** Doom setup
#+begin_src emacs-lisp
(load "~/.doom.d/personal.el")
#+end_src

#+BEGIN_SRC emacs-lisp

;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
(setq doom-font (font-spec :family "Jetbrains Mono" :size 14))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-one)

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c g k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c g d') to jump to their definition and see how
;; they are implemented.

#+END_SRC
** Clear authinfo cache
Somewhere this is filled with trash. Clear it
#+BEGIN_SRC emacs-lisp
(after! auth-source (auth-source-forget-all-cached) )
#+END_SRC
** Mac fixes
*** Fix mac modifiers
#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta nil)
(setq mac-command-key-is-meta t)
(setq mac-command-modifier 'meta)
(setq mac-option-modifier nil)
#+END_SRC
*** Fix frame size
To make sure frame has correct size on yabai
#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC
* Desktop
** packages
#+begin_src emacs-lisp :tangle packages.el
(package! exwm)
#+end_src
** Functions
*** Utilities
**** Helper function to start background apps
#+begin_src emacs-lisp
(defun my/run-in-background (command &optional working-dir)
  (let ((command-parts (split-string command "[ ]+"))
        (default-directory (or working-dir default-directory)))
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))
#+end_src
**** Update default-directory
#+begin_src emacs-lisp
(defun my/exwm--set-cwd ()
  (let* ((id (exwm--buffer->id (current-buffer)))
         (response (xcb:+request-unchecked+reply exwm--connection
                       (make-instance 'xcb:ewmh:get-_NET_WM_PID :window id)))
         (pid (and response (slot-value response 'value)))
         (cwd (and pid (file-chase-links (format "/proc/%d/cwd" pid) 1))))
    (if (and cwd (file-accessible-directory-p cwd))
        (setq-local default-directory (file-name-as-directory cwd))
      (when (boundp 'user-home-directory) (setq-local default-directory user-home-directory)))))
#+end_src
*** Launch apps on login
#+begin_src emacs-lisp
(defun my/start-apps-on-login ()
  (my/run-in-background "~/.config/polybar/launch_polybar.sh")
  (my/run-in-background "dunst")
  (my/run-in-background "nm-applet")
  (my/run-in-background "pasystray")
  (my/run-in-background "blueman-applet")
  (my/run-in-background "dropbox")
  (my/run-in-background "flameshot")
  (setenv "LPASS_AGENT_TIMEOUT" "0")
  (my/run-in-background (format "lpass login %s" user-mail-address))
  )
#+end_src
*** Hooks
**** Rename buffer to EXWM window name
#+begin_src emacs-lisp
(defun my/exwm-update-class ()
  (exwm-workspace-rename-buffer (format "%s - %s" exwm-class-name exwm-title)))

(advice-add #'exwm--update-utf8-title
            :before-while
            (defun exwm--update-utf8-title-a (id &optional force)
              (get-buffer-window (exwm--id->buffer id))))
#+end_src
**** Extra config after exwm is initialized
#+begin_src emacs-lisp
(defun my/exwm-init-hook ()
  (my/start-apps-on-login)
  )
#+end_src
**** Auto workspace
Some applications should always open in a specific workspace, so we move them as soon as possible
#+begin_src emacs-lisp
(defvar my/exwm-buffer-default-workspace-alist '()
  "Associate exwm class name to default workspace")

(setq my/exwm-buffer-default-workspace-alist '(("Spotify" . "Musikk")
                                               ("Slack" . "Kommunikasjon")
                                               ("Microsoft Teams - Preview" . "Kommunikasjon")
                                               ("discord" . "Kommunikasjon")
                                               ))

(when (featurep! :ui workspaces)
  (after! (:all exwm persp-mode)
    (persp-def-auto-persp
     "exwm"
     :dont-pick-up-buffers t
     :parameters '((dont-save-to-file . t))
     :mode 'exwm-mode
     :dyn-env '(after-switch-to-buffer-functions ;; prevent recursion
                (persp-add-buffer-on-find-file nil)
                persp-add-buffer-on-after-change-major-mode)
     :hooks '(exwm-update-class-hook)
     :switch 'window
     :predicate (lambda (buffer &optional state)
                  (and
                   exwm-class-name
                   (assoc exwm-class-name my/exwm-buffer-default-workspace-alist)
                   (not (memq xcb:Atom:_NET_WM_WINDOW_TYPE_SPLASH exwm-window-type))
                   (or state t)))
     :get-name (lambda (state)
                 (append (list
                          (cons 'old-persp (get-current-persp))
                          (cons 'persp-name (cdr (assoc exwm-class-name my/exwm-buffer-default-workspace-alist))))
                         state))
     :after-match (lambda (state)
                    (unless (string= (alist-get 'persp-name state) (persp-name (alist-get 'old-persp state)))
                      (persp-remove-buffer (alist-get 'buffer state) (alist-get 'old-persp state)))
                    (+workspace-switch (alist-get 'persp-name state) t)
                    (switch-to-buffer (alist-get 'buffer state))
                    (+workspace/display))
     )))
#+end_src
**** Config for new EXWM buffers
#+begin_src emacs-lisp
(defun my/exwm-mode-hook ()
  (doom-mark-buffer-as-real-h))
#+end_src
**** Input change hook
#+begin_src emacs-lisp
(defun my/exwm-on-enter-char-mode ()
  (setq exwm-input-line-mode-passthrough nil)
  (setq exwm--ewmh-state
        (delq xcb:Atom:_NET_WM_STATE_HIDDEN exwm--ewmh-state))
  )

(defun my/exwm-on-enter-line-mode ()
  (setq exwm-input-line-mode-passthrough t)
  )

(defun my/exwm-handle-input-state ()
  (pcase exwm--selected-input-mode
    ('char-mode (my/exwm-on-enter-char-mode))
    ('line-mode (my/exwm-on-enter-line-mode)))
  )
#+end_src
*** Advice
#+begin_src emacs-lisp
(defun my/switch-buffer-advice (orig-fun &rest args)
  (letf! ((defun ivy--switch-buffer-action (buffer)
            "Switch to BUFFER.
BUFFER may be a string or nil."
            (if (zerop (length buffer))
                (switch-to-buffer
                 ivy-text nil 'force-same-window)
              (let ((virtual (assoc buffer ivy--virtual-buffers))
                    (view (assoc buffer ivy-views)))
                (cond ((and virtual
                            (not (get-buffer buffer)))
                       (find-file (cdr virtual)))
                      (view
                       (delete-other-windows)
                       (let (
                             ;; silence "Directory has changed on disk"
                             (inhibit-message t))
                         (ivy-set-view-recur (cadr view))))
                      (t
                       (exwm-workspace-switch-to-buffer buffer))))))
          )

    (apply orig-fun args)
    )
  )
#+end_src
*** Insert/normal state
#+begin_src emacs-lisp
(defun my/exwm-enter-char-mode ()
  (call-interactively 'exwm-input-release-keyboard))

(defun my/exwm-escape ()
  "Switch to normal state, and cancel possible fullscreen layout.  Also close minibuffer."
  (interactive)
  (call-interactively 'exwm-input-grab-keyboard)
  (exwm-layout-unset-fullscreen)
  (when (active-minibuffer-window)
    (minibuffer-keyboard-quit)))
#+end_src

*** Workarounds
**** Popups randomly closing
#+begin_src emacs-lisp
(setq exwm-manage-configurations
        `(((equal exwm-instance-name "sun-awt-X11-XDialogPeer")
           managed t
           floating t)))
#+end_src
** Keybindings
*** Global keys
#+begin_src emacs-lisp
(defun my/exwm-set-global-keys ()
  (setq exwm-input-global-keys
        `(
          ;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
          ([?\s-r] . exwm-reset)
          ([?\C-q] . my/exwm-escape)
          ([?\s-c] . exwm-input-release-keyboard)

          ;; Move between windows
          ([s-left] . windmove-left)
          ([s-right] . windmove-right)
          ([s-up] . windmove-up)
          ([s-down] . windmove-down)
          ;; ([?\s- ] . counsel-linux-app)
          ([?\s- ] . my/run-rofi)


          ;; Launch applications via shell command
          ([?\s-&] . (lambda (command)
                       (interactive (list (read-shell-command "$ ")))
                       (start-process-shell-command command nil command)))

          ;; Switch workspace
          ([?\s-w] . exwm-workspace-switch)

          ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))))
  (define-key exwm-mode-map (kbd "C-c") nil)
  (evil-define-key 'normal exwm-mode-map (kbd "i") 'exwm-input-release-keyboard)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-1>" ) 'exwm-input-release-keyboard)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-2>" ) 'exwm-input-release-keyboard)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-3>" ) 'exwm-input-release-keyboard)
  )
#+end_src
*** Simulation keys
#+begin_src emacs-lisp
;; (map! :map exwm-mode-map
;;       :n "j" (cmd! ())
;;       )
#+end_src
*** Window management
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "Desktop")
       :desc "Buffer" "b" #'exwm-workspace-switch-to-buffer
       :desc "Reset" "r" #'exwm-reset
       :desc "Floating hide" "h" #'exwm-floating-hide
       :desc "Switch workspace" "w" #'exwm-workspace-switch
       :desc "Add workspace" "a" #'exwm-workspace-add
       :desc "Delete workspace" "d" #'exwm-workspace-delete
       :desc "Move window to workspace" "m" #'exwm-workspace-move-window
       :desc "Swap workspace" "s" #'exwm-workspace-swap
       :desc "Detatch minibuffer" "Md" #'exwm-workspace-detach-minibuffer
       :desc "Attach minibuffer" "Ma" #'exwm-workspace-attach-minibuffer
       :desc "Open app" "SPC" #'counsel-linux-app
       ))
#+end_src
** Initialize
#+begin_src emacs-lisp
(set-popup-rule! "^\\*EXWM" :ignore t)

(use-package! exwm
  :commands exwm-enable
  :custom
  (exwm-workspace-number 2)
  (exwm-workspace-show-all-buffers t)
  (exwm-layout-show-all-buffers t)

  :config
  (require 'exwm-randr)

  (setq exwm-randr-workspace-output-plist '(0 "DP-2" 1 "DP-4"))
  (add-hook 'exwm-randr-screen-change-hook
            (lambda ()
              (start-process-shell-command
               "xrandr" nil "xrandr --output DP-2 --auto --left-of DP-4 --primary")))

  (exwm-randr-enable)

  ;; (require 'exwm-systemtray)
  ;; (exwm-systemtray-enable)
  (add-hook 'exwm-update-class-hook #'my/exwm-update-class)
  (add-hook 'exwm-init-hook #'my/exwm-init-hook)
  (add-hook 'exwm-manage-finish-hook #'my/exwm-enter-char-mode)
  (add-hook 'exwm-manage-finish-hook #'my/exwm--set-cwd)
  (add-hook 'exwm-mode-hook #'my/exwm-mode-hook)
  (add-hook 'exwm-update-title-hook #'my/exwm-update-class)
  (add-hook 'exwm-input-input-mode-change-hook #'my/exwm-handle-input-state)

  (when (featurep! :completion ivy)
    (advice-add '+ivy/switch-workspace-buffer :around #'my/switch-buffer-advice)
    )
  (my/exwm-set-global-keys)

  (setq my/exwm-char-mode-class-names '("jetbrains-idea"))
  )
#+end_src
** Desktop environment
Handle media keys and such
#+begin_src emacs-lisp :tangle packages.el
(package! desktop-environment)
#+end_src
#+begin_src emacs-lisp
(use-package! desktop-environment
  :after exwm
  :config (desktop-environment-mode))
#+end_src
** Plugins
*** exwm-edit
#+begin_src emacs-lisp :tangle packages.el
(package! exwm-edit)
#+end_src

#+begin_src emacs-lisp
(use-package! exwm-edit
  :commands #'exwm-edit--compose
  :hook (exwm-edit-compose . turn-on-undo-tree-mode)
  :init
  (defadvice! my/exwm-edit--display-buffer-a (orig-fn buf)
    :around #'exwm-edit--display-buffer
    (pop-to-buffer buf))
  (map! :leader
      (:prefix "d"
       :desc "Edit" "e" #'exwm-edit--compose
       ))
  :config
  (global-exwm-edit-mode t))
#+end_src
*** Mouse follow focus
#+begin_src emacs-lisp :tangle packages.el
(package! exwm-mff
  :recipe (:host github :repo "ieure/exwm-mff"))
#+end_src

#+begin_src emacs-lisp
(use-package! exwm-mff
  :commands exwm-mff-mode
  ;; :init
  ;; (add-hook! 'exwm-init-hook #'exwm-mff-mode)
  )
#+end_src
** Apps
*** IntelliJ
Open IntelliJ in current project or if it already exists in project, open file in running instance.
#+begin_src emacs-lisp
(defun my/idea-in-project ()
  (interactive)
  "Open IntelliJ IDEA in project root."

  (my/run-in-background (format "idea %s" (if (buffer-file-name)
                                              (format ". %s" (buffer-file-name))
                                            "."))
                        (projectile-project-root))

  (let* ((exwm-buffers (--filter (exwm--buffer->id it) (+workspace-buffer-list) ))
         (idea-window (car (--filter (with-current-buffer it (string= "jetbrains-idea" exwm-class-name)) exwm-buffers))))
    (when idea-window (switch-to-buffer idea-window)))
  )
#+end_src
*** Brave
#+begin_src emacs-lisp
(defun my/brave-in-project ()
  (interactive)
  "Open Brave browser in project root."
  (my/run-in-background "brave" (projectile-project-root)))
#+end_src
*** Rofi
#+begin_src emacs-lisp
(defun my/run-rofi ()
  (interactive)
  (my/run-in-background "rofi -show drun"))
#+end_src
*** Qutebrowser
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser"
      browse-url-generic-args '("--target" "window")
      )
#+end_src
*** Keybinds
#+begin_src emacs-lisp
(map! :leader
      :prefix ("a" . "Applications")
      :desc "IDEA" "i" #'my/idea-in-project
      :desc "Browser" "b" #'my/brave-in-project)
#+end_src
** Custom modeline
#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment exwm-modals
    (when (exwm--buffer->id (current-buffer))
      (doom-modeline--modal-icon
       (format "%s" exwm--selected-input-mode)
       (pcase exwm--selected-input-mode
         ('char-mode 'doom-modeline-evil-insert-state)
         ('line-mode 'doom-modeline-evil-normal-state)
         )
       (format "%s" exwm--selected-input-mode)
       ))
    )

  (doom-modeline-def-modeline 'exwm-modeline
    '(bar window-number exwm-modals buffer-info)
    '(major-mode))

  (defun my/exwm-modeline ()
    (doom-modeline-set-modeline 'exwm-modeline))
  (add-hook 'exwm-mode-hook 'my/exwm-modeline)
  )
#+end_src
* Keybindings
* Plugin configuration
** Evil
#+begin_src emacs-lisp
(setq evil-move-cursor-back nil)
#+end_src
** Alert
#+begin_src emacs-lisp
(setq alert-default-style (cond (IS-LINUX 'notifications)
                                (IS-MAC 'osx-notifier)
                                (t 'message)))
#+end_src
** Polymode
#+begin_src emacs-lisp :tangle packages.el
(package! polymode)
#+end_src
#+begin_src emacs-lisp
(use-package! polymode)
#+end_src
** COMMENT mmm-mode
#+begin_src emacs-lisp :tangle packages.el
(package! mmm-mode)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! mmm-mode)
#+END_SRC
** Org mode
*** Setup
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org/")

#+end_src
*** org-roam
**** File locations
Org roam will track all org files
#+begin_src emacs-lisp
(setq org-roam-directory  org-directory)
#+end_src
but only capture to the roam directory to not create a mess with normal org files
#+begin_src emacs-lisp
(setq org-roam-capture-templates
      '(("d" "default" plain #'org-roam-capture--get-point "%?" :file-name "roam/%<%Y%m%d%H%M%S>-${slug}" :head "#+title: ${title}\n" :unnarrowed t)))
#+end_src
**** Setup
#+begin_src emacs-lisp
(setq org-roam-graph-viewer nil)
#+end_src
**** Dailies
Daily notes goes to ~org/daily~
#+begin_src emacs-lisp
(setq org-roam-dailies-directory "daily/")
#+end_src
Set up two contexts. One for random notes and another for storing link to capture location
#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")
        ("c" "With context" entry
         #'org-roam-capture--get-point
         "* %?\n%a"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")))
#+end_src
Probably a temporary fix to make SPC-n-r consistent with SPC-m-m bindings
#+begin_src emacs-lisp
(map! :leader
      (:prefix "n"
       (:prefix "r"
        (:prefix "d"
         :desc "Capture daily" "n" #'org-roam-dailies-capture-today
         :desc "Capture daily" "c" #'org-roam-dailies-capture-today
         ))))
#+end_src
**** Fix agenda category
#+begin_src emacs-lisp
(setq org-agenda-prefix-format
      '((agenda . " %i %-12:(+org-entry-category)%?-12t% s")
        (todo . " %i %-12:(+org-entry-category)")
        (tags . " %i %-12:(+org-entry-category)")
        (search . " %i %-12:(+org-entry-category)")))

(defun +org-entry-category ()
  "Get category of item at point.

Supports `org-roam' filenames by chopping prefix cookie."
  (+string-chop-prefix-regexp
   "^[0-9]+\\-"
   (or (org-entry-get nil "CATEGORY")
       "")))

;; requires s.el
(defun +string-chop-prefix-regexp (prefix s)
  "Remove PREFIX regexp if it is at the start of S."
  (s-chop-prefix (car (s-match prefix s)) s))
#+end_src
**** Don't open roam buffer by default
#+begin_src emacs-lisp
(setq +org-roam-open-buffer-on-find-file nil)
#+end_src
*** Looks
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ▼")
#+END_SRC
*** org-agenda
**** Only show top level in agenda
#+begin_src emacs-lisp
(setq org-agenda-todo-list-sublevels nil)
#+end_src
**** Populate from external sources
I want to view my meetings and jira tasks in my agenda. Jira tasks are synced with org-jira while calendars are imported into the diary.
#+begin_src emacs-lisp
(setq org-agenda-include-diary t)

(defun my/import-daily-tasks ()
  "Import calendars to diary and "
  (interactive)
  (call-interactively #'my/import-calendars)
  (call-interactively #'org-jira-get-issues))

(map! :leader
      (:prefix "n"
       :desc "Import agenda items" "i" #'my/import-daily-tasks))
#+end_src

Fetching items from the diary can be really slow. This is because when the agenda includes it, it will show the entire description which causes some slowness. Here I add an advice to remove everything after the summary
#+begin_src emacs-lisp
(setq icalendar-import-format-description "\n Desc: %s")
(defun my/agenda-remove-desc-from-diary (orig-fun extra txt &optional level category tags dotime
				                  remove-re habitp)
  (apply orig-fun
         (list extra
               (if (string-equal category "Diary") (car (s-split ";" txt)) txt)
               level category tags dotime remove-re habitp)))

(advice-add 'org-agenda-format-item :around #'my/agenda-remove-desc-from-diary)
#+end_src
To speed it up even further, cache the result
#+begin_src emacs-lisp
(defvar my/remembered-diary-items '())

(setq my/remembered-diary-items '())

(defun my/remember-diary-items (orig-fun date)
  (or (cdr (assoc date my/remembered-diary-items))
      (let ((ret (apply orig-fun (list date))))
        (add-to-list 'my/remembered-diary-items (cons date ret))
        ret
        )))

(advice-add 'org-get-entries-from-diary :around #'my/remember-diary-items)
#+end_src
**** Popup
Agenda window shoult show in a popup window
#+BEGIN_SRC emacs-lisp
(after! org-agenda
  (set-popup-rule! "^\\*Org Agenda\\*"
    :side 'right
    :size 120
    :modeline t)
  )
#+END_SRC
**** Agenda files
Recursively find files in ~org-directory~
#+BEGIN_SRC emacs-lisp
(defun refresh-org-agenda-files ()
  (setq org-agenda-files (directory-files-recursively org-directory "\.org$")))

(defun refresh-org-agenda-advice (orig-fun &rest args)
  (message "Refresh org-agenda files")
  (refresh-org-agenda-files)
  (apply orig-fun args))

(after! org-agenda
  (setq org-agenda-tag-filter-preset '("-noagenda"))
  (advice-add  'org-agenda-redo :around #'refresh-org-agenda-advice)
  (refresh-org-agenda-files))
#+END_SRC
**** org-super-agenda
#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! org-super-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-header-map (make-sparse-keymap)
        org-agenda-start-with-log-mode t))
(custom-set-faces
 '(org-super-agenda-header ((t (:inherit org-agenda-structure :foreground  "#a9a1e1")))))
#+END_SRC
***** Define the groups
****** Workday
The workday page will show
- Jira issues I am currently working on
- Tasks scheduled for today
- Other work tasks
- A timeline of all meetings scheduled today
  #+BEGIN_SRC emacs-lisp
(defun my/create-agenda-workday ()
  '("w" "Workday"
    ((alltodo "" ((org-agenda-span 'day)
                  (org-super-agenda-groups
                   '(
                     (:name "JIRA-issues"
                      :file-path "/org-jira/")
                     (:name "Today"
                      :and (:not (:category "private")
                            :scheduled today)
                      :and (:not (:category "private")
                            :scheduled past)
                      )
                     (:name "Unscheduled"
                      :and (:category "work"
                            :not (:habit t)))
                     (:name "Personal"
                      :and (:category "private"
                            :date today))
                     (:discard (:anything t))

                     ))))
     (agenda "" ((org-agenda-span 'day)
                 (org-agenda-start-day nil)
                 (org-agenda-overriding-header "")
                 (org-agenda-time-grid '((daily today require-timed)
                                         (800 1000 1200 1400 1600 1800 2000)
                                         "......" "----------------"))
                 (org-agenda-skip-scheduled-if-done t)
                 (org-agenda-skip-deadline-if-done t)
                 (org-agenda-include-deadlines t)
                 (org-agenda-include-diary t)
                 (org-agenda-block-separator nil)
                 (org-agenda-compact-blocks t)
                 (org-agenda-start-with-log-mode nil)
                 (org-agenda-show-log nil)
                 (org-super-agenda-groups
                  '((:name "Today's meetings"
                     :time-grid t
                     :and (:date today
                           :not (:tag "my-issues")
                           )
                     ;; :scheduled today
                     )
                    (:discard (:anything t))))))))
  )
  #+END_SRC
****** Worklog
Show a timeline of the work I clocked and meetings attended for a given day
#+BEGIN_SRC emacs-lisp
(defun my/create-agenda-worklog ()
  '("l" "Logged work"
    ((agenda ""
             ((org-agenda-span 'day)
              (org-agenda-start-day "-1d")
              (org-agenda-time-grid '((daily require-timed)
                                      (800 1000 1200 1400 1600 1800 2000)
                                      "......" "----------------"))
              (org-super-agenda-groups
               '((:name "What I did"
                  :time-grid t)
                 (:discard (:anything t)))
               ))))))
#+END_SRC

***** And register them
  #+BEGIN_SRC emacs-lisp
  (after! org-super-agenda
    (setq org-agenda-custom-commands
          (list (my/create-agenda-workday)
                (my/create-agenda-worklog))))
  #+END_SRC
**** Appointment notification
Configure notifications to display 11, 5 and 1 minutes before start. Notifications are turned on when imported.
#+begin_src emacs-lisp
(setq appt-message-warning-time 11
      appt-display-interval 5
      appt-display-diary nil)
#+end_src
*** org-capture
Copied from doom org-capture autoload. Should figure out a better way to do this
#+BEGIN_SRC emacs-lisp
(after! org-capture
  (defun +org--capture-ensure-heading (headings &optional initial-level)
    (if (not headings)
        (widen)
      (let ((initial-level (or initial-level 1)))
        (if (and (re-search-forward (format org-complex-heading-regexp-format
                                            (regexp-quote (car headings)))
                                    nil t)
                 (= (org-current-level) initial-level))
            (progn
              (beginning-of-line)
              (org-narrow-to-subtree))
          (goto-char (point-max))
          (unless (and (bolp) (eolp)) (insert "\n"))
          (insert (make-string initial-level ?*)
                  " " (car headings) "\n")
          (beginning-of-line 0))
        (+org--capture-ensure-heading (cdr headings) (1+ initial-level)))))

  (defun +org--capture-central-file (file project)
    (let ((file (expand-file-name file org-directory)))
      (set-buffer (org-capture-target-buffer file))
      (org-capture-put-target-region-and-position)
      (widen)
      (goto-char (point-min))
      ;; Find or create the project headling
      (+org--capture-ensure-heading
       (append (org-capture-get :parents)
               (list project (org-capture-get :heading))))))
  )
#+END_SRC

**** Templates
***** Template strings
#+BEGIN_SRC emacs-lisp
(defvar my/org-template-todo-string "** TODO %?\n%i\n%a")
(defvar my/org-template-note-string "* %U %?\n %i\n %a")
#+END_SRC

***** Centralized projects
Project entries should go in projects.org file under ~projectile-project-name~ headline
#+BEGIN_SRC emacs-lisp
(defun +org-capture-central-project-file ()
  "File for project notes and tasks"
  (+org--capture-central-file "projects.org" (projectile-project-name)))
#+END_SRC
****** todo
Todos goes under ~Tasks~
#+BEGIN_SRC emacs-lisp
(defun my/org-template-project-todo ()
  '("Projects"
    entry (function +org-capture-central-project-file)
    "** TODO %?\n%i\n%a"
    :heading "Tasks" :prepend nil))
#+END_SRC
****** note
~ Notes goes under ~notes~
#+BEGIN_SRC emacs-lisp
(defun my/org-template-project-note ()
  '("Project notes"
    entry (function +org-capture-central-project-file)
    "* %U %?\n %i\n %a"
    :heading "Notes" :prepend t)
  )
#+END_SRC
***** Personal
#+BEGIN_SRC emacs-lisp
(defun +org-capture-personal-inbox ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "private.org" "Inbox"))
#+END_SRC
****** todo
#+BEGIN_SRC emacs-lisp
(defun my/org-template-personal-todo ()
      `("Personal todo"
        entry (function +org-capture-personal-inbox)
        ;; entry (function (+org--capture-central-file "private.org" "Inbox"))
        "** TODO %?\n%i"
        :heading "Tasks" :prepend nil))
#+END_SRC
****** note
#+BEGIN_SRC emacs-lisp
(defun my/org-template-personal-note ()
      `("Personal notes"
        entry (function +org-capture-personal-inbox)
        "* %U %?\n %i"
        :heading "Notes" :prepend t)
      )
#+END_SRC
***** Work
#+BEGIN_SRC emacs-lisp
(defun +org-capture-work-inbox ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "work.org" "Inbox"))
#+END_SRC
****** todo
#+BEGIN_SRC emacs-lisp
(defun my/org-template-work-todo ()
      `("Work todo"
        entry (function +org-capture-work-inbox)
        "** TODO %?\n%i"
        :heading "Tasks" :prepend nil))
#+END_SRC
****** note
#+BEGIN_SRC emacs-lisp
(defun my/org-template-work-note ()
      `("Work notes"
        entry (function +org-capture-work-inbox)
        "* %U %?\n %i"
        :heading "Tasks" :prepend t)
      )
#+END_SRC
***** Annoyance
Capture annoyances for retro
#+BEGIN_SRC emacs-lisp
(defun +org-capture-work-annoyances ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "work.org" "Retro"))
(defun my/org-template-work-annoyance ()
  `("Annoyances"
    entry (function +org-capture-work-annoyances)
    "* %U %?\n %i"
    :heading ,(format-time-string "Week: %V"))
  )
#+END_SRC
***** Email
#+begin_src emacs-lisp
(defun my/org-template-email-followup ()
  '("Email to follow up"
    entry (file+headline "email.org" "Follow up")
    "* TODO %a %?\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))"))
#+end_src
***** Update list
#+BEGIN_SRC emacs-lisp
(after! org-capture
  (setq org-capture-templates
        `(
          ("t" . ,(my/org-template-personal-todo))
          ("n" . ,(my/org-template-personal-note))

          ("e" . ,(my/org-template-email-followup))

          ("p" "Project")
          ("pt" . ,(my/org-template-project-todo))
          ("pn" . ,(my/org-template-project-note))

          ("w" "Work")
          ("wt" . ,(my/org-template-work-todo))
          ("wn" . ,(my/org-template-work-note))
          ("wa" . ,(my/org-template-work-annoyance))
          )))
#+END_SRC
*** org-depend
#+BEGIN_SRC emacs-lisp
(after! org
  (require 'org-depend))
#+END_SRC
*** org-jira
#+begin_src emacs-lisp :tangle packages.el
(package! org-jira)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! org-jira
  :commands (org-jira-mode org-jira-get-issues org-jira-update-worklogs-from-org-clocks)
  :init
  (require 'cl)

  (setq org-jira-working-dir "~/Dropbox/org/org-jira"
        org-jira-use-status-as-todo nil
        org-jira-done-states '("Done" "Prod" "PROD" "Closed" "Resolved" "Accept" "Dev (Done)")
        org-jira-jira-status-to-org-keyword-alist
        '(("In Progress" . "STRT")
          ("DEV" . "DONE")
          ("Dev (Done)" . "DONE")
          ("Demo" . "DONE")
          ("Pull request" . "HOLD")
          ("Pull Request" . "HOLD")
          ("Prod" . "DONE")
          ("rejected" . "KILL")))
  (make-directory org-jira-working-dir 'parents)
  )
#+END_SRC
*** COMMENT org tanglesync
#+begin_src emacs-lisp :tangle packages.el
(package! org-tanglesync
  :disable t)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! org-tanglesync
  :hook ((org-mode . org-tanglesync-mode)
         ;; enable watch-mode globally:
         ((prog-mode text-mode) . org-tanglesync-watch-mode))
  :init
  (setq org-tanglesync-watch-files '("~/code/technipfmc/access-management/pentest/usermutation.org")
        org-tanglesync-watch-mode 1)

  :bind
  (( "C-c M-i" . org-tanglesync-process-buffer-interactive)
   ( "C-c M-a" . org-tanglesync-process-buffer-automatic)))
#+END_SRC
*** Visual fill column
#+begin_src emacs-lisp :tangle packages.el
(package! visual-fill-column)
#+end_src
#+BEGIN_SRC emacs-lisp
(defun my/org-mode-visual-fill ()
  (setq visual-fill-column-width 180)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . my/org-mode-visual-fill))
#+END_SRC
*** org-wild-notifier
#+begin_src emacs-lisp :tangle packages.el
(package! org-wild-notifier)
#+end_src
#+begin_src emacs-lisp
(use-package! org-wild-notifier
  :init
  (setq org-wild-notifier-keyword-whitelist '())
  :config
  (org-wild-notifier-mode 1))
#+end_src
*** org-clock
#+begin_src emacs-lisp
(setq org-clock-clocked-in-display nil)
#+end_src
*** Additional exporters
**** Slack
#+begin_src emacs-lisp :tangle packages.el
(package! ox-slack)
#+end_src

#+begin_src emacs-lisp
(use-package! ox-slack)
#+end_src
*** Custom configuration
**** jira/pomodoro
Insert the task id from last started pomodoro
#+begin_src emacs-lisp
(when (featurep! :lang org +pomodoro)
  (defun my/get-task-id ()
    (save-window-excursion
      (org-clock-goto)
      (cdr (assoc "ID" (org-entry-properties)))))

  (defun my/insert-task-id ()
    (interactive)
    (let ((id (my/get-task-id)))
      (if id (progn
               (evil-append 1)
               (insert id)
               (evil-normal-state)))))

  (map! :leader
        (:prefix "i"
         :desc "Task ID" "t" #'my/insert-task-id
         ))
  )
#+end_src
**** Import files
Copy the file into dropbox and insert a link to it
#+begin_src emacs-lisp
(setq my/org-file-import-dir "~/Dropbox/org/filer")

(defun my/import-file ()
  "Select a file into 'my/org-file-import-dir'"
  (interactive)
  (let* ((imported-file-link nil))
    (save-window-excursion
      (counsel-find-file "~/")
      (let* ((old-file-name (file-name-nondirectory (buffer-file-name)))
             (new-dirname (format "%s/%s/%s"
                                  my/org-file-import-dir
                                  (format-time-string "%Y" (current-time))
                                  (format-time-string "%m" (current-time))
                                  ))
             (new-file-path (format "%s/%s-%s" new-dirname
                                    (format-time-string "%Y%m%d%H%M%S" (current-time))
                                    old-file-name)))
        (message "%s -> %s" old-file-name new-file-path)
        (make-directory new-dirname 'parents)
        (copy-file (buffer-file-name) new-file-path)
        (setq imported-file (format "[[%s][%s]]" new-file-path old-file-name))
        ))
    (insert imported-file))
  )
#+end_src

**** Open notes in workspace
Set ~org-roam-find-file~ as default note finding binding. It will not include non-org files.
#+begin_src emacs-lisp
(global-set-key [remap +default/find-in-notes] #'org-roam-find-file)
#+end_src

Make sure notes are opened in ~Notes~ workspace
#+begin_src emacs-lisp
(defun my/switch-to-notes-workspace ()
  "Open notes workspace. If it doesn't exist, open roam index."
  (let ((exists (+workspace-exists-p "Notes")))
    (+workspace-switch "Notes" t)
    (when (not exists)
      (org-roam-jump-to-index))
    (+workspace/display)))

(advice-add 'org-roam-find-file :before #'my/switch-to-notes-workspace)
(advice-add '+default/org-notes-search :before #'my/switch-to-notes-workspace)
(advice-add 'org-agenda-switch-to :before #'my/switch-to-notes-workspace)
#+end_src
** Calendar
Monday is first day of the week
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
(map! (:leader
       :prefix-map ("o" . "open")
       :desc "calendar" "c" #'=calendar))

(setq +calendar-open-function #'my/open-calendar)
#+END_SRC
** Ivy
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion ivy)
  (setq ivy-use-selectable-prompt t)
  )
#+END_SRC
** Tree sitter
#+begin_src emacs-lisp :tangle packages.el
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! tree-sitter)
(use-package! tree-sitter-langs
  :after tree-sitter
  :config
  (tree-sitter-require 'tsx)
  (add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx)))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(setq projectile-project-search-path '("~/code" "~/code/work")
      projectile-switch-project-action 'projectile-vterm)
#+END_SRC
** Lastpass
#+begin_src emacs-lisp :tangle packages.el
(package! lastpass)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! lastpass
  :custom
  (lastpass-user user-mail-address)
  (lastpass-trust-login t)
  :config
  (lastpass-auth-source-enable)
)
#+END_SRC
** COMMENT Webkit
 Requires emacs 28
#+begin_src emacs-lisp :tangle packages.el
(package! webkit
  :disable t
  :recipe (:host github :repo "akirakyle/emacs-webkit"
           :branch "main"
           :files (:defaults "*.js" "*.css" "*.el" "*.so")
           :build ("make")))
#+end_src
#+begin_src emacs-lisp
(use-package! webkit)
#+end_src
** Terminal
*** vterm
#+begin_src emacs-lisp
(when (featurep! :term vterm)
  (setq vterm-buffer-name-string "vterm: %s"))
#+end_src
** LSP
#+begin_src emacs-lisp
(setq lsp-file-watch-threshold 20000)
#+end_src
** Git
*** Yadm dotfile management
#+begin_src emacs-lisp
(after! tramp
  (add-to-list 'tramp-methods
               '("yadm"
                 (tramp-login-program "yadm")
                 (tramp-login-args (("enter")))
                 (tramp-login-env (("SHELL") ("/bin/sh")))
                 (tramp-remote-shell "/bin/sh")
                 (tramp-remote-shell-args ("-c"))))
  )
(defun yadm-status ()
  "Magit status form yadm dotfiles"
  (interactive)
  (magit-status "/yadm::"))
#+end_src
*** Commit format
We use commitlint with max summary length 100
#+begin_src emacs-lisp
(setq git-commit-summary-max-length 100)
#+end_src
*** CircleCI magit integration
#+begin_src emacs-lisp :tangle packages.el
(package! magit-circleci)
#+end_src
#+begin_src emacs-lisp
(use-package! magit-circleci
  :commands magit-circleci-mode
  :config
  (setq magit-circleci-token (auth-source-pick-first-password :host "circleci.magit.token" )))
#+end_src
** Emacs Everywhere
#+begin_src emacs-lisp
(setq! emacs-everywhere-markdown-apps '("Discord" "Slack"))
#+end_src
** Email
#+begin_src emacs-lisp :tangle packages.el
(package! mu4e-thread-folding
  :disable t
  :recipe (:host github :repo "rougier/mu4e-thread-folding"))
#+end_src
#+begin_src emacs-lisp
  (use-package! mu4e-thread-folding
    :after mu4e
    :config
    (setq +mu4e-header-colorized-faces
          '(all-the-icons-green
            all-the-icons-lblue
            all-the-icons-purple-alt
            all-the-icons-blue-alt
            all-the-icons-purple
            all-the-icons-yellow))
    (add-to-list 'mu4e-header-info-custom
                 '(:empty .
                   (:name "Empty"
                    :shortname ""
                    :function (lambda (msg) "  ")))
                 )
    (setq mu4e-headers-fields
          '(
            (:empty . 2)
            (:account . 12)
            (:human-date . 12)
            (:flags . 4)
            (:from . 25)
            (:subject . 235)
            (:maildir . 20)
            ))
    (map! :map (mu4e-view-header-field-keymap mu4e-view-mode-map mu4e-headers-mode-map)
          :n "f" #'mu4e-org-store-and-capture)
    )
#+end_src
** Window configuration
Configure so both evil-window (windmove) and ace windows works for all frames
#+begin_src emacs-lisp :tangle packages.el
(package! framemove :recipe (:host github :repo "emacsmirror/framemove"))
#+end_src
#+begin_src emacs-lisp
(use-package! framemove
  :after windmove
  :init
  (setq framemove-hook-into-windmove t))
(after! ace-window
  (setq aw-scope 'global
        ace-window-display-mode t))
(map! :leader
      (:prefix "w"
       :desc "Switch window all frames" "f" #'ace-window))
#+end_src
** AWS
*** AWS logs
#+begin_src emacs-lisp :tangle packages.el
(package! aws-logs
  :recipe (:host github :repo "hansffu/aws-logs.el"))
#+end_src
#+begin_src emacs-lisp
(use-package! aws-logs
  :commands aws-logs
  :config
  (set-popup-rule! "^\\*AWS logs - "
    :side 'bottom
    :size 120)
  )
#+end_src
Localstack logs
#+begin_src emacs-lisp
(defun localstack-logs ()
  (interactive)
  (let ((aws-logs-endpoint "http://localhost:4566"))
    (aws-logs)))
#+end_src
keybindings
#+begin_src emacs-lisp
(map! :leader
      :prefix ("l" . "Logs")
      :desc "AWS" "a" #'aws-logs
      :desc "Localstack" "l" #'localstack-logs)
#+end_src
** vterm
#+begin_src emacs-lisp
(remove-hook! vterm-mode 'hide-mode-line-mode)
#+end_src
** Jest
#+begin_src emacs-lisp :tangle packages.el
(package! jest-test-mode)
#+end_src
#+begin_src emacs-lisp
(use-package! jest-test-mode
  :defer t
  :commands jest-test-mode
  :init
  (add-hook 'typescript-mode-hook 'jest-test-mode)
  (add-hook 'js-mode-hook 'jest-test-mode)
  (add-hook 'typescript-tsx-mode-hook 'jest-test-mode))
#+end_src
** Code compass
#+begin_src emacs-lisp :tangle packages.el
(package! code-compass
  :disable t
  :recipe (:host github :repo "ag91/code-compass"
           :files ("*")))
#+end_src
#+begin_src emacs-lisp
(use-package! code-compass)
#+end_src
** Elfeed
#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-goodies
  :disable t)
#+end_src
#+begin_src emacs-lisp
(use-package! elfeed-goodies
  :after elfeed
  :config
  (elfeed-goodies/setup))
#+end_src
** Workspaces
#+begin_src emacs-lisp
(when (featurep! :ui workspaces)
  (after! persp-mode
    (map! :leader
          "-" #'+workspace/switch-to
          "1" #'+workspace/switch-to-0
          "2" #'+workspace/switch-to-1
          "3" #'+workspace/switch-to-2
          "4" #'+workspace/switch-to-3
          "5" #'+workspace/switch-to-4
          "6" #'+workspace/switch-to-5
          "7" #'+workspace/switch-to-6
          "8" #'+workspace/switch-to-7
          "9" #'+workspace/switch-to-8
          "0" #'+workspace/switch-to-final)))
#+end_src
** Treemacs
#+begin_src emacs-lisp
(setq +treemacs-git-mode 'deferred)
#+end_src
** Uuid
#+begin_src emacs-lisp :tangle packages.el
(package! uuidgen)
#+end_src
#+begin_src emacs-lisp
(use-package! uuidgen
  :commands (uuidgen
             uuidgen-1
             uuidgen-3
             uuidgen-4
             uuidgen-5
             uuidgen-cid
             uuidgen-urn
             insert-uuid-cid)
  :init
  (map! :leader
        (:prefix "i"
         :desc "UUID" "U" #'uuidgen))
  )
#+end_src

* Languages
** Web
*** nvm
#+begin_src emacs-lisp :tangle packages.el
(package! nvm)
#+end_src
#+begin_src emacs-lisp
(use-package! nvm
  :config
  (nvm-use "14"))
#+end_src
*** Yarn
#+begin_src emacs-lisp
(defun my/run-tests-in-file ()
  (interactive)
  (compile (format "yarn test %s" (buffer-file-name (buffer-base-buffer)))))

(map! :map (typescript-mode-map typescript-tsx-mode-map)
      :leader
      (:prefix "r"
       :desc "Run tests in file" "t" #'my/run-tests-in-file) )
#+end_src
*** typescript
#+BEGIN_SRC emacs-lisp
;; (setq-hook! '(typescript-mode-local-vars-hook typescript-tsx-mode-local-vars-hook)
;;   +format-with-lsp nil)
(add-hook! (typescript-mode typescript-tsx-mode) #'tree-sitter-hl-mode)

;; (define-derived-mode typescript-tsx-mode typescript-mode "TSX"
;;   "Major mode for editing TSX files.
(setq tree-sitter-hl-use-font-lock-keywords nil)
;; Refer to Typescript documentation for syntactic differences between normal and TSX
;; variants of Typescript.")

(setq-hook! '(typescript-tsx-mode-hook typescript-mode-hook)
  +format-with-lsp nil)

(setq typescript-indent-level 2
      ;; lsp-clients-typescript-log-verbosity "info"
      lsp-clients-typescript-plugins
      (vector
       (list :name "@vsintellicode/typescript-intellicode-plugin"
             :location "~/.vscode/extensions/visualstudioexptteam.vscodeintellicode-1.2.11/")))

#+END_SRC

**** COMMENT Inline html
#+begin_src emacs-lisp
(after! (:and mmm-mode typescript-mode)
  (mmm-add-classes
   '((ts-html
      :submode web-mode
      :face mmm-declaration-submode-face
      :front "[^a-zA-Z]html`" ;; regex to find the opening tag
      :back "`"))) ;; regex to find the closing tag
  (mmm-add-mode-ext-class 'typescript-mode nil 'ts-html)
  (setq mmm-global-mode 'maybe)
  (setq mmm-submode-decoration-level 0)
  )
#+end_src

**** Inline graphql
#+begin_src emacs-lisp
(after! (:and polymode)

  (define-innermode poly-typescript-graphql-innermode
    :mode 'graphql-mode
    :head-matcher "[^a-zA-Z]gql`"
    :tail-matcher "`"
    :head-mode 'host
    :tail-mode 'host)

  (define-hostmode poly-typescript-hostmode
    :mode 'typescript-mode)
  (define-polymode poly-typescript-mode
    :hostmode 'poly-typescript-hostmode
    :innermodes '(poly-typescript-graphql-innermode))

  (define-hostmode poly-typescript-tsx-hostmode
    :mode 'typescript-tsx-mode)
  (define-polymode poly-typescript-tsx-mode
    :hostmode 'poly-typescript-tsx-hostmode
    :innermodes '(poly-typescript-graphql-innermode))
  )
#+end_src
** GraphQL
Set up graphql with lsp
#+begin_src emacs-lisp :tangle packages.el
(package! graphql-mode)
(package! ob-graphql)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! graphql-mode
  :hook (graphql-mode . lsp!)
  :mode "\\.graphqls?\\'"
  :config
  (after! lsp-mode

    (defcustom lsp-vscode-graphql-debug nil "Enable debug logs" :type
      '(repeat boolean))
    (defcustom lsp-vscode-graphql-trace-server "off" "Enable tracing for language server" :type
      '(repeat string))
    (defcustom lsp-vscode-graphql-show-exec-codelens t "Show codelens to execute operations inline" :type 'boolean)
    (defcustom lsp-vscode-graphql-use-schema-file-definitions nil "Use local SDL/IDL files for definition lookups. Default is to use generated_schema.graphql from GraphQL Config settings for definitions" :type 'boolean)
    (defcustom lsp-graphql-config-load-root-dir nil "Base dir for graphql config loadConfig()" :type
      '(repeat string))
    (defcustom lsp-graphql-config-load-file-path nil "filePath for graphql config loadConfig()" :type
      '(repeat string))
    (defcustom lsp-graphql-config-load-legacy nil "legacy mode for graphql config v2 config" :type 'boolean)
    (defcustom lsp-graphql-config-load-config-name nil "optional <configName>.config.js instead of default `graphql`" :type
      '(repeat string))
    (defcustom lsp-graphql-config-dot-env-path nil "optional .env load path, if not the default" :type
      '(repeat string))
    (lsp-register-custom-settings
     '(("graphql-config.dotEnvPath" lsp-graphql-config-dot-env-path)
       ("graphql-config.load.configName" lsp-graphql-config-load-config-name)
       ("graphql-config.load.legacy" lsp-graphql-config-load-legacy t)
       ("graphql-config.load.filePath" lsp-graphql-config-load-file-path)
       ("graphql-config.load.rootDir" lsp-graphql-config-load-root-dir)
       ("vscode-graphql.useSchemaFileDefinitions" lsp-vscode-graphql-use-schema-file-definitions t)
       ("vscode-graphql.showExecCodelens" lsp-vscode-graphql-show-exec-codelens t)
       ("vscode-graphql.trace.server" lsp-vscode-graphql-trace-server)
       ("vscode-graphql.debug" lsp-vscode-graphql-debug)))
    (lsp-register-client
     (make-lsp-client :new-connection
                      (lsp-tcp-connection (lambda (port) `("graphql-lsp" "server" "-m" "socket" "-p" ,(number-to-string port))))
                      :major-modes '(graphql-mode)
                      :initialization-options (lambda () `())
                      :server-id 'graphql))
    (add-to-list 'lsp-language-id-configuration '(graphql-mode . "graphql"))
    (lsp-enable-which-key-integration 'graphql-mode)
    )
  )
#+END_SRC
Set up from org mode as well
#+BEGIN_SRC emacs-lisp
(use-package! ob-graphql)
#+END_SRC

*** COMMENT Syntax highlight in js/jsx/ts/tsx
#+BEGIN_SRC emacs-lisp
(after! (:and graphql-mode mmm-mode typescript-mode)
  (mmm-add-classes
   '((ts-graphql
      :submode graphql-mode
      :face mmm-declaration-submode-face
      :front "[^a-zA-Z]gql`" ;; regex to find the opening tag
      :back "`"))) ;; regex to find the closing tag
  (mmm-add-mode-ext-class 'typescript-mode nil 'ts-graphql)
  (setq mmm-global-mode 'maybe)
  (setq mmm-submode-decoration-level 0)
  )
#+END_SRC
** Rescript (ReasonML)
#+begin_src emacs-lisp :tangle packages.el
(package! reason-mode)
#+end_src
#+BEGIN_SRC emacs-lisp
(use-package! reason-mode
  :mode ("\\.re?s\\'" . reason-mode)
  :config
  (after! lsp-mode
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "/usr/bin/reason-language-server")
                      :major-modes '(reason-mode)
                      :notification-handlers (ht ("client/registerCapability" 'ignore))
                      :priority 1
                      :server-id 'reason-ls)))

  (add-hook 'reason-mode-local-vars-hook #'lsp!)
  )
#+END_SRC
* Fun
** Speed types
#+begin_src emacs-lisp :tangle packages.el
(package! speed-type)
#+end_src
#+BEGIN_SRC
(use-package! speed-type)
#+END_SRC
** Spongebob mocking
#+begin_src emacs-lisp
(defun my/spongebob-mocking ()
  (interactive)
  (save-excursion
    (let ((eol (save-excursion (progn (end-of-line) (point)))))
      (beginning-of-line-text)

      (while (< (point) eol)
        (upcase-char 1)
        (forward-char 2)
        ))
    ))
#+end_src
