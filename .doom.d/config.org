#+TITLE: Personal emacs config
#+STARTUP: overview

* Workarounds
** 28.0.50
#+begin_src emacs-lisp
(defun make-obsolete (obsolete-name current-name &optional when)
  "Make the byte-compiler warn that function OBSOLETE-NAME is obsolete.
OBSOLETE-NAME should be a function name or macro name (a symbol).

The warning will say that CURRENT-NAME should be used instead.
If CURRENT-NAME is a string, that is the `use instead' message
\(it should end with a period, and not start with a capital).
WHEN should be a string indicating when the function
was first made obsolete, for example a date or a release number."
  (declare (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when) "23.1"))
  (put obsolete-name 'byte-obsolete-info
       ;; The second entry used to hold the `byte-compile' handler, but
       ;; is not used any more nowadays.
       (purecopy (list current-name nil when)))
  obsolete-name)

(defmacro define-obsolete-function-alias (obsolete-name current-name
                                                        &optional when docstring)
  "Set OBSOLETE-NAME's function definition to CURRENT-NAME and mark it obsolete.

\(define-obsolete-function-alias \\='old-fun \\='new-fun \"22.1\" \"old-fun's doc.\")

is equivalent to the following two lines of code:

\(defalias \\='old-fun \\='new-fun \"old-fun's doc.\")
\(make-obsolete \\='old-fun \\='new-fun \"22.1\")

WHEN should be a string indicating when the function was first
made obsolete, for example a date or a release number.

See the docstrings of `defalias' and `make-obsolete' for more details."
  (declare (doc-string 4)
           (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when &optional docstring) "23.1"))
  `(progn
     (defalias ,obsolete-name ,current-name ,docstring)
     (make-obsolete ,obsolete-name ,current-name ,when)))

(defun make-obsolete-variable (obsolete-name current-name &optional when access-type)
  "Make the byte-compiler warn that OBSOLETE-NAME is obsolete.
The warning will say that CURRENT-NAME should be used instead.
If CURRENT-NAME is a string, that is the `use instead' message.
WHEN should be a string indicating when the variable
was first made obsolete, for example a date or a release number.
ACCESS-TYPE if non-nil should specify the kind of access that will trigger
  obsolescence warnings; it can be either `get' or `set'."
  (declare (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when &optional access-type) "23.1"))
  (put obsolete-name 'byte-obsolete-variable
       (purecopy (list current-name access-type when)))
  obsolete-name)

(defmacro define-obsolete-variable-alias (obsolete-name current-name
						        &optional when docstring)
  "Make OBSOLETE-NAME a variable alias for CURRENT-NAME and mark it obsolete.
This uses `defvaralias' and `make-obsolete-variable' (which see).
See the Info node `(elisp)Variable Aliases' for more details.

If CURRENT-NAME is a defcustom or a defvar (more generally, any variable
where OBSOLETE-NAME may be set, e.g. in an init file, before the
alias is defined), then the define-obsolete-variable-alias
statement should be evaluated before the defcustom, if user
customizations are to be respected.  The simplest way to achieve
this is to place the alias statement before the defcustom (this
is not necessary for aliases that are autoloaded, or in files
dumped with Emacs).  This is so that any user customizations are
applied before the defcustom tries to initialize the
variable (this is due to the way `defvaralias' works).

WHEN should be a string indicating when the variable was first
made obsolete, for example a date or a release number.

For the benefit of Customize, if OBSOLETE-NAME has
any of the following properties, they are copied to
CURRENT-NAME, if it does not already have them:
`saved-value', `saved-variable-comment'."
  (declare (doc-string 4)
           (advertised-calling-convention
            ;; New code should always provide the `when' argument.
            (obsolete-name current-name when &optional docstring) "23.1"))
  `(progn
     (defvaralias ,obsolete-name ,current-name ,docstring)
     ;; See Bug#4706.
     (dolist (prop '(saved-value saved-variable-comment))
       (and (get ,obsolete-name prop)
            (null (get ,current-name prop))
            (put ,current-name prop (get ,obsolete-name prop))))
     (make-obsolete-variable ,obsolete-name ,current-name ,when)))
#+end_src

* Setup
** Doom setup
#+INCLUDE: "./personal.el" src emacs-lisp

#+BEGIN_SRC emacs-lisp

;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
(setq doom-font (font-spec :family "Jetbrains Mono" :size 14))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-one)

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c g k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c g d') to jump to their definition and see how
;; they are implemented.

#+END_SRC
** Clear authinfo cache
Somewhere this is filled with trash. Clear it
#+BEGIN_SRC emacs-lisp
(after! auth-source (auth-source-forget-all-cached) )
#+END_SRC
** Mac fixes
*** Fix mac modifiers
#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta nil)
(setq mac-command-key-is-meta t)
(setq mac-command-modifier 'meta)
(setq mac-option-modifier nil)
#+END_SRC
*** Fix frame size
To make sure frame has correct size on yabai
#+BEGIN_SRC emacs-lisp
(setq frame-resize-pixelwise t)
#+END_SRC
* Desktop
** Functions
*** Utilities
**** Helper function to start background apps
#+begin_src emacs-lisp
(defun my/run-in-background (command &optional working-dir)
  (let ((command-parts (split-string command "[ ]+"))
        (default-directory (or working-dir default-directory)))
    (message "Launching command %s in %s" command default-directory)
    (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))
#+end_src
**** Update default-directory
#+begin_src emacs-lisp
(defun my/exwm--set-cwd ()
  (let* ((id (exwm--buffer->id (current-buffer)))
         (response (xcb:+request-unchecked+reply exwm--connection
                       (make-instance 'xcb:ewmh:get-_NET_WM_PID :window id)))
         (pid (and response (slot-value response 'value)))
         (cwd (and pid (file-chase-links (format "/proc/%d/cwd" pid) 1))))
    (if (and cwd (file-accessible-directory-p cwd))
        (setq-local default-directory (file-name-as-directory cwd))
      (when (boundp 'user-home-directory) (setq-local default-directory user-home-directory)))))
#+end_src
*** Launch apps on login
#+begin_src emacs-lisp
(defun my/start-apps-on-login ()
  (my/run-in-background "~/.config/polybar/launch_polybar.sh")
  (my/run-in-background "dunst")
  (my/run-in-background "nm-applet")
  (my/run-in-background "pasystray")
  (my/run-in-background "blueman-applet")
  (my/run-in-background "dropbox")
  (my/run-in-background "flameshot")
  (setenv "LPASS_AGENT_TIMEOUT" "0")
  (my/run-in-background (format "lpass login %s" user-mail-address))
  )
#+end_src
*** Hooks
**** Rename buffer to EXWM window name
#+begin_src emacs-lisp
(defun my/exwm-update-class ()
  (exwm-workspace-rename-buffer (format "%s - %s" exwm-class-name exwm-title)))

(advice-add #'exwm--update-utf8-title
            :before-while
            (defun exwm--update-utf8-title-a (id &optional force)
              (get-buffer-window (exwm--id->buffer id))))
#+end_src
**** Extra config after exwm is initialized
#+begin_src emacs-lisp
(defun my/exwm-init-hook ()
  (my/start-apps-on-login)
  )
#+end_src
**** Auto workspace
Some applications should always open in a specific workspace, so we move them as soon as possible
#+begin_src emacs-lisp
(defvar my/exwm-buffer-default-workspace-alist '()
  "Associate exwm class name to default workspace")

(setq my/exwm-buffer-default-workspace-alist '(("Spotify" . "Musikk")
                                               ("Slack" . "Kommunikasjon")
                                               ;; ("Microsoft Teams - Preview" . "Kommunikasjon")
                                               ("discord" . "Kommunikasjon")
                                               ))

(when (featurep! :ui workspaces)
  (after! (:all exwm persp-mode)
    (persp-def-auto-persp
     "exwm"
     :dont-pick-up-buffers t
     :parameters '((dont-save-to-file . t))
     :mode 'exwm-mode
     :dyn-env '(after-switch-to-buffer-functions ;; prevent recursion
                (persp-add-buffer-on-find-file nil)
                persp-add-buffer-on-after-change-major-mode)
     :hooks '(exwm-update-class-hook)
     :switch 'window
     :predicate (lambda (buffer &optional state)
                  (and
                   exwm-class-name
                   (assoc exwm-class-name my/exwm-buffer-default-workspace-alist)
                   (not (memq xcb:Atom:_NET_WM_WINDOW_TYPE_SPLASH exwm-window-type))
                   (or state t)))
     :get-name (lambda (state)
                 (append (list
                          (cons 'old-persp (get-current-persp))
                          (cons 'persp-name (cdr (assoc exwm-class-name my/exwm-buffer-default-workspace-alist))))
                         state))
     :after-match (lambda (state)
                    (unless (string= (alist-get 'persp-name state) (persp-name (alist-get 'old-persp state)))
                      (persp-remove-buffer (alist-get 'buffer state) (alist-get 'old-persp state)))
                    (+workspace-switch (alist-get 'persp-name state) t)
                    (switch-to-buffer (alist-get 'buffer state))
                    (+workspace/display))
     )))
#+end_src
**** Config for new EXWM buffers
#+begin_src emacs-lisp
(defun my/exwm-mode-hook ()
  (doom-mark-buffer-as-real-h))
#+end_src
**** Input change hook
#+begin_src emacs-lisp
(defun my/exwm-on-enter-char-mode ()
  (setq exwm-input-line-mode-passthrough nil)
  (setq exwm--ewmh-state
        (delq xcb:Atom:_NET_WM_STATE_HIDDEN exwm--ewmh-state))
  (evil-insert-state))

(defun my/exwm-on-enter-line-mode ()
  (setq exwm-input-line-mode-passthrough t)
  (evil-normal-state)
  )

(defun my/exwm-handle-input-state ()
  (pcase exwm--selected-input-mode
    ('char-mode (my/exwm-on-enter-char-mode))
    ('line-mode (my/exwm-on-enter-line-mode)))
  )
#+end_src
*** Advice
#+begin_src emacs-lisp
(defun my/switch-buffer-advice (orig-fun &rest args)
  (letf! ((defun ivy--switch-buffer-action (buffer)
            "Switch to BUFFER.
BUFFER may be a string or nil."
            (if (zerop (length buffer))
                (switch-to-buffer
                 ivy-text nil 'force-same-window)
              (let ((virtual (assoc buffer ivy--virtual-buffers))
                    (view (assoc buffer ivy-views)))
                (cond ((and virtual
                            (not (get-buffer buffer)))
                       (find-file (cdr virtual)))
                      (view
                       (delete-other-windows)
                       (let (
                             ;; silence "Directory has changed on disk"
                             (inhibit-message t))
                         (ivy-set-view-recur (cadr view))))
                      (t
                       (exwm-workspace-switch-to-buffer buffer))))))
          )

    (apply orig-fun args)
    )
  )
#+end_src
*** Insert/normal state
#+begin_src emacs-lisp
(defun my/exwm-enter-char-mode ()
  (call-interactively 'exwm-input-release-keyboard))

(defun my/exwm-escape ()
  "Switch to normal state, and cancel possible fullscreen layout.  Also close minibuffer."
  (interactive)
  (call-interactively 'exwm-input-grab-keyboard)
  (exwm-layout-unset-fullscreen)
  (when (active-minibuffer-window)
    (minibuffer-keyboard-quit)))
#+end_src

** Keybindings
*** Global keys
#+begin_src emacs-lisp
(defun my/exwm-set-global-keys ()
  (setq exwm-input-global-keys
        `(
          ;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
          ([?\s-r] . exwm-reset)
          ([?\C-q] . my/exwm-escape)
          ([?\s-c] . exwm-input-release-keyboard)

          ;; Move between windows
          ([s-left] . windmove-left)
          ([s-right] . windmove-right)
          ([s-up] . windmove-up)
          ([s-down] . windmove-down)
          ;; ([?\s- ] . counsel-linux-app)
          ([?\s- ] . my/run-rofi)


          ;; Launch applications via shell command
          ([?\s-&] . (lambda (command)
                       (interactive (list (read-shell-command "$ ")))
                       (start-process-shell-command command nil command)))

          ;; Switch workspace
          ([?\s-w] . exwm-workspace-switch)

          ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))))
  (define-key exwm-mode-map (kbd "C-c") nil)
  (evil-define-key 'normal exwm-mode-map (kbd "i") 'exwm-input-release-keyboard)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-1>" ) 'exwm-input-release-keyboard)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-2>" ) 'exwm-input-release-keyboard)
  (evil-define-key 'normal exwm-mode-map (kbd "<down-mouse-3>" ) 'exwm-input-release-keyboard)
  )
#+end_src
*** Simulation keys
#+begin_src emacs-lisp
;; (map! :map exwm-mode-map
;;       :n "j" (cmd! ())
;;       )
#+end_src
*** Window management
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "Desktop")
       :desc "Buffer" "b" #'exwm-workspace-switch-to-buffer
       :desc "Reset" "r" #'exwm-reset
       :desc "Floating hide" "h" #'exwm-floating-hide
       :desc "Switch workspace" "w" #'exwm-workspace-switch
       :desc "Add workspace" "a" #'exwm-workspace-add
       :desc "Delete workspace" "d" #'exwm-workspace-delete
       :desc "Move window to workspace" "m" #'exwm-workspace-move-window
       :desc "Swap workspace" "s" #'exwm-workspace-swap
       :desc "Detatch minibuffer" "Md" #'exwm-workspace-detach-minibuffer
       :desc "Attach minibuffer" "Ma" #'exwm-workspace-attach-minibuffer
       :desc "Open app" "SPC" #'counsel-linux-app
       ))
#+end_src
** Initialize
#+begin_src emacs-lisp
(set-popup-rule! "^\\*EXWM" :ignore t)

(use-package! exwm
  :commands exwm-enable
  :custom
  (exwm-workspace-number 2)
  (exwm-workspace-show-all-buffers t)
  (exwm-layout-show-all-buffers t)

  :config
  (require 'exwm-randr)

  (setq exwm-randr-workspace-output-plist '(0 "DP-2" 1 "DP-4"))
  (add-hook 'exwm-randr-screen-change-hook
            (lambda ()
              (start-process-shell-command
               "xrandr" nil "xrandr --output DP-2 --auto --left-of DP-4 --primary")))

  (exwm-randr-enable)

  ;; (require 'exwm-systemtray)
  ;; (exwm-systemtray-enable)
  (add-hook 'exwm-update-class-hook #'my/exwm-update-class)
  (add-hook 'exwm-init-hook #'my/exwm-init-hook)
  (add-hook 'exwm-manage-finish-hook #'my/exwm-enter-char-mode)
  (add-hook 'exwm-manage-finish-hook #'my/exwm--set-cwd)
  (add-hook 'exwm-mode-hook #'my/exwm-mode-hook)
  (add-hook 'exwm-update-title-hook #'my/exwm-update-class)
  (add-hook 'exwm-input-input-mode-change-hook #'my/exwm-handle-input-state)

  (advice-add '+ivy/switch-workspace-buffer :around #'my/switch-buffer-advice)
  (my/exwm-set-global-keys)

  (setq my/exwm-char-mode-class-names '("jetbrains-idea"))
  )
#+end_src
** Desktop environment
Handle media keys and such
#+begin_src emacs-lisp
(use-package! desktop-environment
  :after exwm
  :config (desktop-environment-mode))
#+end_src
** Plugins
*** exwm-edit
#+begin_src emacs-lisp
(use-package! exwm-edit
  :commands #'exwm-edit--compose
  :hook (exwm-edit-compose . turn-on-undo-tree-mode)
  :init
  (defadvice! my/exwm-edit--display-buffer-a (orig-fn buf)
    :around #'exwm-edit--display-buffer
    (pop-to-buffer buf))
  (map! :leader
      (:prefix "d"
       :desc "Edit" "e" #'exwm-edit--compose
       ))
  :config
  (global-exwm-edit-mode t))
#+end_src
*** Mouse follow focus
#+begin_src emacs-lisp
(use-package! exwm-mff
  :commands exwm-mff-mode
  :init
  (add-hook! 'exwm-init-hook #'exwm-mff-mode))
#+end_src
** Apps
*** IntelliJ
Open IntelliJ in current project or if it already exists in project, open file in running instance.
#+begin_src emacs-lisp
(defun my/idea-in-project ()
  (interactive)
  "Open IntelliJ IDEA in project root."

  (my/run-in-background (format "idea %s" (if (buffer-file-name)
                                              (format ". %s" (buffer-file-name))
                                            "."))
                        (projectile-project-root))

  (let* ((exwm-buffers (--filter (exwm--buffer->id it) (+workspace-buffer-list) ))
         (idea-window (car (--filter (with-current-buffer it (string= "jetbrains-idea" exwm-class-name)) exwm-buffers))))
    (when idea-window (switch-to-buffer idea-window)))
  )
#+end_src
*** Brave
#+begin_src emacs-lisp
(defun my/brave-in-project ()
  (interactive)
  "Open Brave browser in project root."
  (my/run-in-background "brave" (projectile-project-root)))
#+end_src
*** Rofi
#+begin_src emacs-lisp
(defun my/run-rofi ()
  (interactive)
  (my/run-in-background "rofi -show drun"))
#+end_src
*** Qutebrowser
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser"
      browse-url-generic-args '("--target" "window")
      )
#+end_src
*** Keybinds
#+begin_src emacs-lisp
(map! :leader
      :prefix ("a" . "Applications")
      :desc "IDEA" "i" #'my/idea-in-project
      :desc "Browser" "b" #'my/brave-in-project)
#+end_src
* Keybindings
* Plugin configuration
** Alert
#+begin_src emacs-lisp
(setq alert-default-style (cond (IS-LINUX 'notifications)
                                (IS-MAC 'osx-notifier)
                                (t 'message)))
#+end_src
** mmm-mode
#+BEGIN_SRC emacs-lisp
(use-package! mmm-mode)
#+END_SRC
** Org mode
*** Setup
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org/")

#+end_src
*** org-roam
**** File locations
Org roam will track all org files
#+begin_src emacs-lisp
(setq org-roam-directory  org-directory)
#+end_src
but only capture to the roam directory to not create a mess with normal org files
#+begin_src emacs-lisp
(setq org-roam-capture-templates
      '(("d" "default" plain #'org-roam-capture--get-point "%?" :file-name "roam/%<%Y%m%d%H%M%S>-${slug}" :head "#+title: ${title}\n" :unnarrowed t)))
#+end_src
**** Setup
#+begin_src emacs-lisp
(setq org-roam-graph-viewer nil)
#+end_src
**** Dailies
Daily notes goes to ~org/daily~
#+begin_src emacs-lisp
(setq org-roam-dailies-directory "daily/")
#+end_src
Set up two contexts. One for random notes and another for storing link to capture location
#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         #'org-roam-capture--get-point
         "* %?"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")
        ("c" "With context" entry
         #'org-roam-capture--get-point
         "* %?\n%a"
         :file-name "daily/%<%Y-%m-%d>"
         :head "#+title: %<%Y-%m-%d>\n\n")))
#+end_src
Probably a temporary fix to make SPC-n-r consistent with SPC-m-m bindings
#+begin_src emacs-lisp
(map! :leader
      (:prefix "n"
       (:prefix "r"
        (:prefix "d"
         :desc "Capture daily" "n" #'org-roam-dailies-capture-today
         :desc "Capture daily" "c" #'org-roam-dailies-capture-today
         ))))
#+end_src
**** Fix agenda category
#+begin_src emacs-lisp
(setq org-agenda-prefix-format
      '((agenda . " %i %-12:(+org-entry-category)%?-12t% s")
        (todo . " %i %-12:(+org-entry-category)")
        (tags . " %i %-12:(+org-entry-category)")
        (search . " %i %-12:(+org-entry-category)")))

(defun +org-entry-category ()
  "Get category of item at point.

Supports `org-roam' filenames by chopping prefix cookie."
  (+string-chop-prefix-regexp
   "^[0-9]+\\-"
   (or (org-entry-get nil "CATEGORY")
       "")))

;; requires s.el
(defun +string-chop-prefix-regexp (prefix s)
  "Remove PREFIX regexp if it is at the start of S."
  (s-chop-prefix (car (s-match prefix s)) s))
#+end_src
*** Looks
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " â–¼")
#+END_SRC
*** org-agenda
**** Only show top level in agenda
#+begin_src emacs-lisp
(setq org-agenda-todo-list-sublevels nil)
#+end_src
**** Populate from external sources
I want to view my meetings and jira tasks in my agenda. Jira tasks are synced with org-jira while calendars are imported into the diary.
#+begin_src emacs-lisp
(setq org-agenda-include-diary t)

(defun my/import-daily-tasks ()
  "Import calendars to diary and "
  (interactive)
  (call-interactively #'my/import-calendars)
  (call-interactively #'org-jira-get-issues))

(map! :leader
      (:prefix "n"
       :desc "Import agenda items" "i" #'my/import-daily-tasks))
#+end_src

Fetching items from the diary can be really slow. This is because when the agenda includes it, it will show the entire description which causes some slowness. Here I add an advice to remove everything after the summary
#+begin_src emacs-lisp
(setq icalendar-import-format-description "\n Desc: %s")
(defun my/agenda-remove-desc-from-diary (orig-fun extra txt &optional level category tags dotime
				                  remove-re habitp)
  (apply orig-fun
         (list extra
               (if (string-equal category "Diary") (car (s-split ";" txt)) txt)
               level category tags dotime remove-re habitp)))

(advice-add 'org-agenda-format-item :around #'my/agenda-remove-desc-from-diary)
#+end_src
To speed it up even further, cache the result
#+begin_src emacs-lisp
(defvar my/remembered-diary-items '())

(setq my/remembered-diary-items '())

(defun my/remember-diary-items (orig-fun date)
  (or (cdr (assoc date my/remembered-diary-items))
      (let ((ret (apply orig-fun (list date))))
        (add-to-list 'my/remembered-diary-items (cons date ret))
        ret
        )))

(advice-add 'org-get-entries-from-diary :around #'my/remember-diary-items)
#+end_src
**** Popup
Agenda window shoult show in a popup window
#+BEGIN_SRC emacs-lisp
(after! org-agenda
  (set-popup-rule! "^\\*Org Agenda\\*"
    :side 'right
    :size 120
    :modeline t)
  )
#+END_SRC
**** Agenda files
Recursively find files in ~org-directory~
#+BEGIN_SRC emacs-lisp
(defun refresh-org-agenda-files ()
  (setq org-agenda-files (directory-files-recursively org-directory "\.org$")))

(defun refresh-org-agenda-advice (orig-fun &rest args)
  (message "Refresh org-agenda files")
  (refresh-org-agenda-files)
  (apply orig-fun args))

(after! org-agenda
  (setq org-agenda-tag-filter-preset '("-noagenda"))
  (advice-add  'org-agenda-redo :around #'refresh-org-agenda-advice)
  (refresh-org-agenda-files))
#+END_SRC
**** org-super-agenda
#+BEGIN_SRC emacs-lisp
(use-package! org-super-agenda
  :config
  (org-super-agenda-mode)
  (setq org-super-agenda-header-map (make-sparse-keymap)
        org-agenda-start-with-log-mode t))
(custom-set-faces
 '(org-super-agenda-header ((t (:inherit org-agenda-structure :foreground  "#a9a1e1")))))
#+END_SRC
***** Define the groups
****** Workday
The workday page will show
- Jira issues I am currently working on
- Tasks scheduled for today
- Other work tasks
- A timeline of all meetings scheduled today
  #+BEGIN_SRC emacs-lisp
(defun my/create-agenda-workday ()
  '("w" "Workday"
    ((alltodo "" ((org-agenda-span 'day)
                  (org-super-agenda-groups
                   '(
                     (:name "JIRA-issues"
                      :file-path "/org-jira/")
                     (:name "Today"
                      :and (:not (:category "private")
                            :scheduled today)
                      :and (:not (:category "private")
                            :scheduled past)
                      )
                     (:name "Unscheduled"
                      :category "work")
                     (:discard (:anything t))

                     ))))
     (agenda "" ((org-agenda-span 'day)
                 (org-agenda-start-day nil)
                 (org-agenda-overriding-header "")
                 (org-agenda-time-grid '((daily today require-timed)
                                         (800 1000 1200 1400 1600 1800 2000)
                                         "......" "----------------"))
                 (org-agenda-skip-scheduled-if-done t)
                 (org-agenda-skip-deadline-if-done t)
                 (org-agenda-include-deadlines t)
                 (org-agenda-include-diary t)
                 (org-agenda-block-separator nil)
                 (org-agenda-compact-blocks t)
                 (org-agenda-start-with-log-mode nil)
                 (org-agenda-show-log nil)
                 (org-super-agenda-groups
                  '((:name "Today's meetings"
                     :time-grid t
                     :and (:date today
                           :not (:tag "my-issues")
                           )
                     ;; :scheduled today
                     )
                    (:discard (:anything t))))))))
  )
  #+END_SRC
****** Worklog
Show a timeline of the work I clocked and meetings attended for a given day
#+BEGIN_SRC emacs-lisp
(defun my/create-agenda-worklog ()
  '("l" "Logged work"
    ((agenda ""
             ((org-agenda-span 'day)
              (org-agenda-start-day "-1d")
              (org-agenda-time-grid '((daily require-timed)
                                      (800 1000 1200 1400 1600 1800 2000)
                                      "......" "----------------"))
              (org-super-agenda-groups
               '((:name "What I did"
                  :time-grid t)
                 (:discard (:anything t)))
               ))))))
#+END_SRC

***** And register them
  #+BEGIN_SRC emacs-lisp
  (after! org-super-agenda
    (setq org-agenda-custom-commands
          (list (my/create-agenda-workday)
                (my/create-agenda-worklog))))
  #+END_SRC
**** Appointment notification
Configure notifications to display 11, 5 and 1 minutes before start. Notifications are turned on when imported.
#+begin_src emacs-lisp
(setq appt-message-warning-time 11
      appt-display-interval 5
      appt-display-diary nil)
#+end_src
*** org-capture
Copied from doom org-capture autoload. Should figure out a better way to do this
#+BEGIN_SRC emacs-lisp
(after! org-capture
  (defun +org--capture-ensure-heading (headings &optional initial-level)
    (if (not headings)
        (widen)
      (let ((initial-level (or initial-level 1)))
        (if (and (re-search-forward (format org-complex-heading-regexp-format
                                            (regexp-quote (car headings)))
                                    nil t)
                 (= (org-current-level) initial-level))
            (progn
              (beginning-of-line)
              (org-narrow-to-subtree))
          (goto-char (point-max))
          (unless (and (bolp) (eolp)) (insert "\n"))
          (insert (make-string initial-level ?*)
                  " " (car headings) "\n")
          (beginning-of-line 0))
        (+org--capture-ensure-heading (cdr headings) (1+ initial-level)))))

  (defun +org--capture-central-file (file project)
    (let ((file (expand-file-name file org-directory)))
      (set-buffer (org-capture-target-buffer file))
      (org-capture-put-target-region-and-position)
      (widen)
      (goto-char (point-min))
      ;; Find or create the project headling
      (+org--capture-ensure-heading
       (append (org-capture-get :parents)
               (list project (org-capture-get :heading))))))
  )
#+END_SRC

**** Templates
***** Template strings
#+BEGIN_SRC emacs-lisp
(defvar my/org-template-todo-string "** TODO %?\n%i\n%a")
(defvar my/org-template-note-string "* %U %?\n %i\n %a")
#+END_SRC

***** Centralized projects
Project entries should go in projects.org file under ~projectile-project-name~ headline
#+BEGIN_SRC emacs-lisp
(defun +org-capture-central-project-file ()
  "File for project notes and tasks"
  (+org--capture-central-file "projects.org" (projectile-project-name)))
#+END_SRC
****** todo
Todos goes under ~Tasks~
#+BEGIN_SRC emacs-lisp
(defun my/org-template-project-todo ()
  '("Projects"
    entry (function +org-capture-central-project-file)
    "** TODO %?\n%i\n%a"
    :heading "Tasks" :prepend nil))
#+END_SRC
****** note
~ Notes goes under ~notes~
#+BEGIN_SRC emacs-lisp
(defun my/org-template-project-note ()
  '("Project notes"
    entry (function +org-capture-central-project-file)
    "* %U %?\n %i\n %a"
    :heading "Notes" :prepend t)
  )
#+END_SRC
***** Personal
#+BEGIN_SRC emacs-lisp
(defun +org-capture-personal-inbox ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "private.org" "Inbox"))
#+END_SRC
****** todo
#+BEGIN_SRC emacs-lisp
(defun my/org-template-personal-todo ()
      `("Personal todo"
        entry (function +org-capture-personal-inbox)
        ;; entry (function (+org--capture-central-file "private.org" "Inbox"))
        "** TODO %?\n%i"
        :heading "Tasks" :prepend nil))
#+END_SRC
****** note
#+BEGIN_SRC emacs-lisp
(defun my/org-template-personal-note ()
      `("Personal notes"
        entry (function +org-capture-personal-inbox)
        "* %U %?\n %i"
        :heading "Notes" :prepend t)
      )
#+END_SRC
***** Work
#+BEGIN_SRC emacs-lisp
(defun +org-capture-work-inbox ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "work.org" "Inbox"))
#+END_SRC
****** todo
#+BEGIN_SRC emacs-lisp
(defun my/org-template-work-todo ()
      `("Work todo"
        entry (function +org-capture-work-inbox)
        "** TODO %?\n%i"
        :heading "Tasks" :prepend nil))
#+END_SRC
****** note
#+BEGIN_SRC emacs-lisp
(defun my/org-template-work-note ()
      `("Work notes"
        entry (function +org-capture-work-inbox)
        "* %U %?\n %i"
        :heading "Tasks" :prepend t)
      )
#+END_SRC
***** Annoyance
Capture annoyances for retro
#+BEGIN_SRC emacs-lisp
(defun +org-capture-work-annoyances ()
  "Personal capture inbox for notes and tasks"
  (+org--capture-central-file "work.org" "Retro"))
(defun my/org-template-work-annoyance ()
  `("Annoyances"
    entry (function +org-capture-work-annoyances)
    "* %U %?\n %i"
    :heading ,(format-time-string "Week: %V"))
  )
#+END_SRC
***** Email
#+begin_src emacs-lisp
(defun my/org-template-email-followup ()
  '("Email to follow up"
    entry (file+headline "email.org" "Follow up")
    "* TODO %a %?\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))"))
#+end_src
***** Update list
#+BEGIN_SRC emacs-lisp
(after! org-capture
  (setq org-capture-templates
        `(
          ("t" . ,(my/org-template-personal-todo))
          ("n" . ,(my/org-template-personal-note))

          ("e" . ,(my/org-template-email-followup))

          ("p" "Project")
          ("pt" . ,(my/org-template-project-todo))
          ("pn" . ,(my/org-template-project-note))

          ("w" "Work")
          ("wt" . ,(my/org-template-work-todo))
          ("wn" . ,(my/org-template-work-note))
          ("wa" . ,(my/org-template-work-annoyance))
          )))
#+END_SRC
*** org-depend
#+BEGIN_SRC emacs-lisp
(after! org
  (require 'org-depend))
#+END_SRC
*** org-jira
#+BEGIN_SRC emacs-lisp
(use-package! org-jira
  :commands (org-jira-mode org-jira-get-issues org-jira-update-worklogs-from-org-clocks)
  :init
  (require 'cl)

  (setq org-jira-working-dir "~/Dropbox/org/org-jira"
        org-jira-use-status-as-todo nil
        org-jira-done-states '("Done" "Prod" "PROD" "Closed" "Resolved" "Accept")
        org-jira-jira-status-to-org-keyword-alist
        '(("In Progress" . "STRT")
          ("DEV" . "DONE")
          ("Demo" . "DONE")
          ("Pull request" . "HOLD")
          ("Prod" . "DONE")))
  (make-directory org-jira-working-dir 'parents)
  )
#+END_SRC
*** org tanglesync
#+BEGIN_SRC emacs-lisp
(use-package! org-tanglesync
  :hook ((org-mode . org-tanglesync-mode)
         ;; enable watch-mode globally:
         ((prog-mode text-mode) . org-tanglesync-watch-mode))
  :init
  (setq org-tanglesync-watch-files '("~/code/technipfmc/access-management/pentest/usermutation.org")
        org-tanglesync-watch-mode 1)

  :bind
  (( "C-c M-i" . org-tanglesync-process-buffer-interactive)
   ( "C-c M-a" . org-tanglesync-process-buffer-automatic)))
#+END_SRC
*** Visual fill column
#+BEGIN_SRC emacs-lisp
(defun my/org-mode-visual-fill ()
  (setq visual-fill-column-width 180)
  (visual-fill-column-mode 1))

(use-package visual-fill-column
  :hook (org-mode . my/org-mode-visual-fill))
#+END_SRC
*** org-wild-notifier
#+begin_src emacs-lisp
(use-package! org-wild-notifier
  :init
  (setq org-wild-notifier-keyword-whitelist '())
  :config
  (org-wild-notifier-mode 1))
#+end_src
*** org-clock
#+begin_src emacs-lisp
(setq org-clock-clocked-in-display nil)
#+end_src
*** Custom configuration
**** jira/pomodoro
Insert the task id from last started pomodoro
#+begin_src emacs-lisp
(when (featurep! :lang org +pomodoro)
  (defun my/get-task-id ()
    (save-window-excursion
      (org-clock-goto)
      (cdr (assoc "ID" (org-entry-properties)))))

  (defun my/insert-task-id ()
    (interactive)
    (let ((id (my/get-task-id)))
      (if id (progn
               (evil-append 1)
               (insert id)
               (evil-normal-state)))))

  (map! :leader
        (:prefix "i"
         :desc "Task ID" "t" #'my/insert-task-id
         ))
  )
#+end_src
**** Import files
Copy the file into dropbox and insert a link to it
#+begin_src emacs-lisp
(setq my/org-file-import-dir "~/Dropbox/org/filer")

(defun my/import-file ()
  "Select a file into 'my/org-file-import-dir'"
  (interactive)
  (let* ((imported-file-link nil))
    (save-window-excursion
      (counsel-find-file "~/")
      (let* ((old-file-name (file-name-nondirectory (buffer-file-name)))
             (new-dirname (format "%s/%s/%s"
                                  my/org-file-import-dir
                                  (format-time-string "%Y" (current-time))
                                  (format-time-string "%m" (current-time))
                                  ))
             (new-file-path (format "%s/%s-%s" new-dirname
                                    (format-time-string "%Y%m%d%H%M%S" (current-time))
                                    old-file-name)))
        (message "%s -> %s" old-file-name new-file-path)
        (make-directory new-dirname 'parents)
        (copy-file (buffer-file-name) new-file-path)
        (setq imported-file (format "[[%s][%s]]" new-file-path old-file-name))
        ))
    (insert imported-file))
  )
#+end_src

**** Open notes in workspace
Set ~org-roam-find-file~ as default note finding binding. It will not include non-org files.
#+begin_src emacs-lisp
(global-set-key [remap +default/find-in-notes] #'org-roam-find-file)
#+end_src

Make sure notes are opened in ~Notes~ workspace
#+begin_src emacs-lisp
(defun my/switch-to-notes-workspace ()
  "Open notes workspace. If it doesn't exist, open roam index."
  (let ((exists (+workspace-exists-p "Notes")))
    (+workspace-switch "Notes" t)
    (when (not exists)
      (org-roam-jump-to-index))
    (+workspace/display)))

(advice-add 'org-roam-find-file :before #'my/switch-to-notes-workspace)
(advice-add '+default/org-notes-search :before #'my/switch-to-notes-workspace)
(advice-add 'org-agenda-switch-to :before #'my/switch-to-notes-workspace)
#+end_src
** Calendar
Monday is first day of the week
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
(map! (:leader
       :prefix-map ("o" . "open")
       :desc "calendar" "c" #'=calendar))

(setq +calendar-open-function #'my/open-calendar)
#+END_SRC
** Ivy
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion ivy)
  (setq ivy-use-selectable-prompt t)
  )
#+END_SRC
** Tree sitter
#+BEGIN_SRC emacs-lisp
(use-package! tree-sitter)
(use-package! tree-sitter-langs
  :after tree-sitter
  :config
  (tree-sitter-require 'tsx)
  (add-to-list 'tree-sitter-major-mode-language-alist '(typescript-tsx-mode . tsx)))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(setq projectile-project-search-path '("~/code" "~/code/work")
      projectile-switch-project-action 'projectile-vterm)
#+END_SRC
** Lastpass
#+BEGIN_SRC emacs-lisp
(use-package! lastpass
  :custom
  (lastpass-user user-mail-address)
  (lastpass-trust-login t)
  :config
  (lastpass-auth-source-enable)
)
#+END_SRC
** Webkit
#+begin_src emacs-lisp
(use-package! webkit)
#+end_src
** Terminal
*** vterm
#+begin_src emacs-lisp
(when (featurep! :term vterm)
  (setq vterm-buffer-name-string "vterm: %s"))
#+end_src
** LSP
#+begin_src emacs-lisp
(setq lsp-file-watch-threshold 20000)
#+end_src
** Git
*** Yadm dotfile management
#+begin_src emacs-lisp
(after! tramp
  (add-to-list 'tramp-methods
               '("yadm"
                 (tramp-login-program "yadm")
                 (tramp-login-args (("enter")))
                 (tramp-login-env (("SHELL") ("/bin/sh")))
                 (tramp-remote-shell "/bin/sh")
                 (tramp-remote-shell-args ("-c"))))
  )
(defun yadm-status ()
  "Magit status form yadm dotfiles"
  (interactive)
  (magit-status "/yadm::"))
#+end_src
*** Commit format
We use commitlint with max summary length 100
#+begin_src emacs-lisp
(setq git-commit-summary-max-length 100)
#+end_src
** Emacs Everywhere
#+begin_src emacs-lisp
(setq! emacs-everywhere-markdown-apps '("Discord" "Slack"))
#+end_src
** Email
#+begin_src emacs-lisp
  (use-package! mu4e-thread-folding
    :after mu4e
    :config
    (setq +mu4e-header-colorized-faces
          '(all-the-icons-green
            all-the-icons-lblue
            all-the-icons-purple-alt
            all-the-icons-blue-alt
            all-the-icons-purple
            all-the-icons-yellow))
    (add-to-list 'mu4e-header-info-custom
                 '(:empty .
                   (:name "Empty"
                    :shortname ""
                    :function (lambda (msg) "  ")))
                 )
    (setq mu4e-headers-fields
          '(
            (:empty . 2)
            (:account . 12)
            (:human-date . 12)
            (:flags . 4)
            (:from . 25)
            (:subject . 235)
            (:maildir . 20)
            ))
    (map! :map (mu4e-view-header-field-keymap mu4e-view-mode-map mu4e-headers-mode-map)
          :n "f" #'mu4e-org-store-and-capture)
    )
#+end_src
** Window configuration
Configure so both evil-window (windmove) and ace windows works for all frames
#+begin_src emacs-lisp
(use-package! framemove
  :after windmove
  :init
  (setq framemove-hook-into-windmove t))
(after! ace-window
  (setq aw-scope 'global
        ace-window-display-mode t))
(map! :leader
      (:prefix "w"
       :desc "Switch window all frames" "f" #'ace-window))
#+end_src
** AWS
*** AWS logs
#+begin_src emacs-lisp
(use-package! aws-logs
  :commands aws-logs
  :config
  (set-popup-rule! "^\\*AWS logs - "
    :side 'bottom
    :size 120)
  )
#+end_src
Localstack logs
#+begin_src emacs-lisp
(defun localstack-logs ()
  (interactive)
  (let ((aws-logs-endpoint "http://localhost:4566"))
    (aws-logs)))
#+end_src
keybindings
#+begin_src emacs-lisp
(map! :leader
      :prefix ("l" . "Logs")
      :desc "AWS" "a" #'aws-logs
      :desc "Localstack" "l" #'localstack-logs)
#+end_src
** vterm
#+begin_src emacs-lisp
(remove-hook! vterm-mode 'hide-mode-line-mode)
#+end_src
** Jest
#+begin_src emacs-lisp
(use-package! jest-test-mode
  :defer t
  :commands jest-test-mode
  :init
  (add-hook 'typescript-mode-hook 'jest-test-mode)
  (add-hook 'js-mode-hook 'jest-test-mode)
  (add-hook 'typescript-tsx-mode-hook 'jest-test-mode))
#+end_src
** Code compass
#+begin_src emacs-lisp
(use-package! code-compass)
#+end_src
** Elfeed
#+begin_src emacs-lisp
(use-package! elfeed-goodies
  :after elfeed
  :config
  (elfeed-goodies/setup))
#+end_src
** Workspaces
#+begin_src emacs-lisp
(when (featurep! :ui workspaces)
  (after! persp-mode
    (map! :leader
          "-" #'+workspace/switch-to
          "1" #'+workspace/switch-to-0
          "2" #'+workspace/switch-to-1
          "3" #'+workspace/switch-to-2
          "4" #'+workspace/switch-to-3
          "5" #'+workspace/switch-to-4
          "6" #'+workspace/switch-to-5
          "7" #'+workspace/switch-to-6
          "8" #'+workspace/switch-to-7
          "9" #'+workspace/switch-to-8
          "0" #'+workspace/switch-to-final)))
#+end_src
* Languages
** Web
*** nvm
#+begin_src emacs-lisp
(use-package! nvm
  :config
  (nvm-use "14"))
#+end_src
*** typescript
#+BEGIN_SRC emacs-lisp
;; (setq-hook! '(typescript-mode-local-vars-hook typescript-tsx-mode-local-vars-hook)
;;   +format-with-lsp nil)
(add-hook! (typescript-tsx-mode typescript-mode) #'tree-sitter-hl-mode)
(define-derived-mode typescript-tsx-mode typescript-mode "TSX"
  "Major mode for editing TSX files.

Refer to Typescript documentation for syntactic differences between normal and TSX
variants of Typescript.")

(setq-hook! '(typescript-tsx-mode-hook typescript-mode-hook)
  +format-with-lsp nil)

(setq typescript-indent-level 2
      ;; lsp-clients-typescript-log-verbosity "info"
      lsp-clients-typescript-plugins
      (vector
       (list :name "@vsintellicode/typescript-intellicode-plugin"
             :location "~/.vscode/extensions/visualstudioexptteam.vscodeintellicode-1.2.11/")))

#+END_SRC

**** Inline html
#+begin_src emacs-lisp
(after! (:and mmm-mode typescript-mode)
  (mmm-add-classes
   '((ts-html
      :submode web-mode
      :face mmm-declaration-submode-face
      :front "[^a-zA-Z]html`" ;; regex to find the opening tag
      :back "`"))) ;; regex to find the closing tag
  (mmm-add-mode-ext-class 'typescript-mode nil 'ts-html)
  (setq mmm-global-mode 'maybe)
  (setq mmm-submode-decoration-level 0)
  )
#+end_src
** GraphQL
Set up graphql with lsp
#+BEGIN_SRC emacs-lisp
(use-package! graphql-mode
  :hook (graphql-mode . lsp!)
  :mode "\\.graphqls?\\'"
  :config
  (after! lsp-mode

    (defcustom lsp-vscode-graphql-debug nil "Enable debug logs" :type
      '(repeat boolean))
    (defcustom lsp-vscode-graphql-trace-server "off" "Enable tracing for language server" :type
      '(repeat string))
    (defcustom lsp-vscode-graphql-show-exec-codelens t "Show codelens to execute operations inline" :type 'boolean)
    (defcustom lsp-vscode-graphql-use-schema-file-definitions nil "Use local SDL/IDL files for definition lookups. Default is to use generated_schema.graphql from GraphQL Config settings for definitions" :type 'boolean)
    (defcustom lsp-graphql-config-load-root-dir nil "Base dir for graphql config loadConfig()" :type
      '(repeat string))
    (defcustom lsp-graphql-config-load-file-path nil "filePath for graphql config loadConfig()" :type
      '(repeat string))
    (defcustom lsp-graphql-config-load-legacy nil "legacy mode for graphql config v2 config" :type 'boolean)
    (defcustom lsp-graphql-config-load-config-name nil "optional <configName>.config.js instead of default `graphql`" :type
      '(repeat string))
    (defcustom lsp-graphql-config-dot-env-path nil "optional .env load path, if not the default" :type
      '(repeat string))
    (lsp-register-custom-settings
     '(("graphql-config.dotEnvPath" lsp-graphql-config-dot-env-path)
       ("graphql-config.load.configName" lsp-graphql-config-load-config-name)
       ("graphql-config.load.legacy" lsp-graphql-config-load-legacy t)
       ("graphql-config.load.filePath" lsp-graphql-config-load-file-path)
       ("graphql-config.load.rootDir" lsp-graphql-config-load-root-dir)
       ("vscode-graphql.useSchemaFileDefinitions" lsp-vscode-graphql-use-schema-file-definitions t)
       ("vscode-graphql.showExecCodelens" lsp-vscode-graphql-show-exec-codelens t)
       ("vscode-graphql.trace.server" lsp-vscode-graphql-trace-server)
       ("vscode-graphql.debug" lsp-vscode-graphql-debug)))
    (lsp-register-client
     (make-lsp-client :new-connection
                      (lsp-tcp-connection (lambda (port) `("graphql-lsp" "server" "-m" "socket" "-p" ,(number-to-string port))))
                      :major-modes '(graphql-mode)
                      :initialization-options (lambda () `())
                      :server-id 'graphql))
    (add-to-list 'lsp-language-id-configuration '(graphql-mode . "graphql"))
    (lsp-enable-which-key-integration 'graphql-mode)
    )
  )
#+END_SRC
Set up from org mode as well
#+BEGIN_SRC emacs-lisp
(use-package! ob-graphql)
#+END_SRC
*** Syntax highlight in js/jsx/ts/tsx
#+BEGIN_SRC emacs-lisp
(after! (:and graphql-mode mmm-mode typescript-mode)
  (mmm-add-classes
   '((ts-graphql
      :submode graphql-mode
      :face mmm-declaration-submode-face
      :front "[^a-zA-Z]gql`" ;; regex to find the opening tag
      :back "`"))) ;; regex to find the closing tag
  (mmm-add-mode-ext-class 'typescript-mode nil 'ts-graphql)
  (setq mmm-global-mode 'maybe)
  (setq mmm-submode-decoration-level 0)
  )
#+END_SRC
** Rescript (ReasonML)
#+BEGIN_SRC emacs-lisp
(use-package! reason-mode
  :mode ("\\.re?s\\'" . reason-mode)
  :config
  (after! lsp-mode
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "/usr/bin/reason-language-server")
                      :major-modes '(reason-mode)
                      :notification-handlers (ht ("client/registerCapability" 'ignore))
                      :priority 1
                      :server-id 'reason-ls)))

  (add-hook 'reason-mode-local-vars-hook #'lsp!)
  )
#+END_SRC
* Fun
** Speed types
#+BEGIN_SRC
(use-package! speed-type)
#+END_SRC
** Spongebob mocking
#+begin_src emacs-lisp
(defun my/spongebob-mocking ()
  (interactive)
  (save-excursion
    (let ((eol (save-excursion (progn (end-of-line) (point)))))
      (beginning-of-line-text)

      (while (< (point) eol)
        (upcase-char 1)
        (forward-char 2)
        ))
    ))
#+end_src
